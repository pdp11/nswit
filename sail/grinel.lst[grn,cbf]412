SAIL CBF        18:49:39 Wednesday, December 19, 1979   NM+1D.3H.43M.54S.
GRINEL.PAL[GRN,CBF] Created 07:22 Monday, December 17, 1979   LQ+6D.1H.27M.15S.


   GGGGGGGGG         RRRRRRRRRRRR            IIIIIIIII         NNN         NNN      EEEEEEEEEEEEEEE      LLL            
   GGGGGGGGG         RRRRRRRRRRRR            IIIIIIIII         NNN         NNN      EEEEEEEEEEEEEEE      LLL            
GGG         GGG      RRR         RRR            III            NNNNNN      NNN      EEE                  LLL            
GGG         GGG      RRR         RRR            III            NNNNNN      NNN      EEE                  LLL            
GGG                  RRR         RRR            III            NNN   NNN   NNN      EEE                  LLL            
GGG                  RRR         RRR            III            NNN   NNN   NNN      EEE                  LLL            
GGG   GGGGGGGGG      RRRRRRRRRRRR               III            NNN      NNNNNN      EEEEEEEEEEEE         LLL            
GGG   GGGGGGGGG      RRRRRRRRRRRR               III            NNN      NNNNNN      EEEEEEEEEEEE         LLL            
GGG         GGG      RRR   RRR                  III            NNN         NNN      EEE                  LLL            
GGG         GGG      RRR   RRR                  III            NNN         NNN      EEE                  LLL            
GGG         GGG      RRR      RRR               III            NNN         NNN      EEE                  LLL            
GGG         GGG      RRR      RRR               III            NNN         NNN      EEE                  LLL            
   GGGGGGGGG         RRR         RRR         IIIIIIIII         NNN         NNN      EEEEEEEEEEEEEEE      LLLLLLLLLLLLLLL
   GGGGGGGGG         RRR         RRR         IIIIIIIII         NNN         NNN      EEEEEEEEEEEEEEE      LLLLLLLLLLLLLLL



SAIL CBF        18:49:39 Wednesday, December 19, 1979   NM+1D.3H.43M.54S.
GRINEL.PAL[GRN,CBF] Created 07:22 Monday, December 17, 1979   LQ+6D.1H.27M.15S.


PPPPPPPPPPPP               AAA            LLL            
PPPPPPPPPPPP               AAA            LLL            
PPP         PPP         AAA   AAA         LLL            
PPP         PPP         AAA   AAA         LLL            
PPP         PPP      AAA         AAA      LLL            
PPP         PPP      AAA         AAA      LLL            
PPPPPPPPPPPP         AAA         AAA      LLL            
PPPPPPPPPPPP         AAA         AAA      LLL            
PPP                  AAAAAAAAAAAAAAA      LLL            
PPP                  AAAAAAAAAAAAAAA      LLL            
PPP                  AAA         AAA      LLL            
PPP                  AAA         AAA      LLL            
PPP                  AAA         AAA      LLLLLLLLLLLLLLL
PPP                  AAA         AAA      LLLLLLLLLLLLLLL


Switch Settings: L[PALX11] % A D 56V 120W Z ^ 
SAIL CBF        18:49:39 Wednesday, December 19, 1979   NM+1D.3H.43M.54S.
GRINEL.PAL[GRN,CBF] Created 07:22 Monday, December 17, 1979   LQ+6D.1H.27M.15S.


   GGGGGGGGG         RRRRRRRRRRRR            IIIIIIIII         NNN         NNN      EEEEEEEEEEEEEEE      LLL            
   GGGGGGGGG         RRRRRRRRRRRR            IIIIIIIII         NNN         NNN      EEEEEEEEEEEEEEE      LLL            
GGG         GGG      RRR         RRR            III            NNNNNN      NNN      EEE                  LLL            
GGG         GGG      RRR         RRR            III            NNNNNN      NNN      EEE                  LLL            
GGG                  RRR         RRR            III            NNN   NNN   NNN      EEE                  LLL            
GGG                  RRR         RRR            III            NNN   NNN   NNN      EEE                  LLL            
GGG   GGGGGGGGG      RRRRRRRRRRRR               III            NNN      NNNNNN      EEEEEEEEEEEE         LLL            
GGG   GGGGGGGGG      RRRRRRRRRRRR               III            NNN      NNNNNN      EEEEEEEEEEEE         LLL            
GGG         GGG      RRR   RRR                  III            NNN         NNN      EEE                  LLL            
GGG         GGG      RRR   RRR                  III            NNN         NNN      EEE                  LLL            
GGG         GGG      RRR      RRR               III            NNN         NNN      EEE                  LLL            
GGG         GGG      RRR      RRR               III            NNN         NNN      EEE                  LLL            
   GGGGGGGGG         RRR         RRR         IIIIIIIII         NNN         NNN      EEEEEEEEEEEEEEE      LLLLLLLLLLLLLLL
   GGGGGGGGG         RRR         RRR         IIIIIIIII         NNN         NNN      EEEEEEEEEEEEEEE      LLLLLLLLLLLLLLL



SAIL CBF        18:49:39 Wednesday, December 19, 1979   NM+1D.3H.43M.54S.
GRINEL.PAL[GRN,CBF] Created 07:22 Monday, December 17, 1979   LQ+6D.1H.27M.15S.


PPPPPPPPPPPP               AAA            LLL            
PPPPPPPPPPPP               AAA            LLL            
PPP         PPP         AAA   AAA         LLL            
PPP         PPP         AAA   AAA         LLL            
PPP         PPP      AAA         AAA      LLL            
PPP         PPP      AAA         AAA      LLL            
PPPPPPPPPPPP         AAA         AAA      LLL            
PPPPPPPPPPPP         AAA         AAA      LLL            
PPP                  AAAAAAAAAAAAAAA      LLL            
PPP                  AAAAAAAAAAAAAAA      LLL            
PPP                  AAA         AAA      LLL            
PPP                  AAA         AAA      LLL            
PPP                  AAA         AAA      LLLLLLLLLLLLLLL
PPP                  AAA         AAA      LLLLLLLLLLLLLLL


Switch Settings: L[PALX11] % A D 56V 120W Z ^ 
Table of Contents for:    GRINEL.PAL[GRN,CBF]                                     12/19/79   Page I
                          


GRINEL	1	Grinnel Support
	2	Grinnel Data Def
	3	DRV11-B Initiali
	4	Grinnel Executio
	5	Grinnell main lo
	6	Graphics	Grinnel Support                                                   GRINEL.PAL[GRN,CBF] 12/19/79   Page 1
 001                    	.sbttl	Grinnel Support
 002                    
 003                    ; Grinell Instruction Set
 004                    gi.wid==  000000	; Write image data (12 bits of data)
 005                    gi.lsm==  010000	; Load subchannel mask (12 bits of mask)
 006                    gi.wgd==  020000	; Write graphic data (8 bits of data)
 007                    gi.wac==  022000	; Write alphanumeric character (8 bit of character)
 008                    gi.lwm==  024000	; Load write mode. 8 bits of mode
 009                      %wminv==200		;   inverse video
 010                      %wmor== 100		;   inclusive or mode
 011                      %wmsub==040		;   zeros unselected subchannel within a channel
 012                      %wmvec==020		;   vector graphic modes (not rectilinear)
 013                      %wm2hi==010		;   double height mode
 014                      %wm2wi==004		;   double width mode
 015                      %wmscs==002		;   cursor=La+Lb and Ea+Eb rather than La and Ea
 016                      %wmcso==001		;   cursor on
 017                    gi.lum==  026000	; Load update mode.  6 bits of mode.
 018                    			;		0    1      2     3
 019                    			; Update Ea    Ea   Ec	Ea+Eb Ea+Ec  low order 2 bits
 020                    			; Update La    La   Lc  La+Lb La+Lc  middle 2 bits
 021                    			; Scroll Reg   Sr Home  down1  up 1  high order 2 bits
 022                    gi.ers==  030000	; Erase screen
 023                    gi.erl==  032000	; Erase line
 024                    gi.slu==  034000	; Special location update.  7 bits of mode
 025                    			;   low 6 bits defined as for gi.lum
 026                      %smfsc==100		;   "fast scroll" mode
 027                    gi.egw==  036000	; Execute graphic write
 028                    
 029                      %lrfgw==2000		; Load Register Force Graphic Write bit
 030                    gi.ler==  040000	; Load Ea relative
 031                    gi.lea==  044000	; Load Ea
 032                    gi.leb==  050000	; Load Eb
 033                    gi.lec==  054000	; Load Ec
 034                    gi.llr==  060000	; Load La relative
 035                    gi.lla==  064000	; Load La
 036                    gi.llb==  070000	; Load Lb
 037                    gi.llc==  074000	; Load Lc
 038                    
 039                    gi.ldc==  100000	; Load Display Channels (12 bits of channel mask)
 040                    gi.np1==  110000	; No-op 1
 041                    
 042                    gi.spd==  120000	; Select Peripheral Device  12 bits of selection
 043                      %spmrd== 400		;   memory read back
 044                      %spbyt==1000		;   byte unpack
 045                      %spint==2000		;   interrupt enable
 046                      %sptst==4000		;   internal diagnostic test
 047                    
 048                    gi.lpa==  130000	; Load Peripheral Address (12 bits device dependant)
 049                    gi.lpr==  140000	; Load Peripheral Register (12 bits device dependant)
 050                      %lpbyt==6000		;   packed byte mode
 051                      %lpgra==4000		;   graphic data
 052                      %lpima==0000		;   image data
 053                      %lpbys==1000		;   bytes swap mode
 054                      %lpode== 400		;   odd byte at end flag
 055                    	Grinnel Support                                                   GRINEL.PAL[GRN,CBF] 12/19/79   Page 1.1
 056                    
 057                    gi.lpd==  150000	; Load Peripheral Data (12 bits device dependant)
 058                    gi.rpd==  160000	; Read Back Peripheral Data (12 bits device dependant)
 059                    
 060                    gi.nop==  170000	; another No-Op	Grinnel Data Definitions                                          GRINEL.PAL[GRN,CBF] 12/19/79   Page 2
 001                    
 002                    .sbttl	Grinnel Data Definitions
 003                    
 004                    linspc==12.		; 12. vertical scan lines per line
 005           002 004  linscr==512./linspc	; 42. lines on the screen
 006                    chrlin==85.		; 85. characters per line
 007                    
 008                    ; Define a Grinnell line
 009                    dsect <
 010                    gl.ldc:: .word 0	; select channel instruction
 011                    gl.lsm:: .word 0	; select subchannel
 012                    gl.lla:: .word 0	; lla positions vertically on screen (top=1000)
 013                    gl.lea:: .word 0	; lea positions horizontally on screen (left edge=0)
 014                    gl.spd:: .word 0	; select periph dev, byte unpack. Don't really need
 015                    			;  to do this every time, but..
 016                    gl.lpr:: .word 0	; load perhiph dev instr to start byte upack sequence
 017           002 006  gl.chr:: .blkb chrlin	; chrlin characters in a line
 018                    	.even
 019                    	>,lgrnl		; lgrnl= length of a grinnel line in bytes
 020                    
 021                    ; Define all the storage needed to run 1 Grinnell screen
 022                    dsect <
 023           002 005  gs.lin:: .blkw linscr	; pointers to first char in each line, index by line
 024                    ;gs.xps:: .word 0	; horizontal position (not sure if I'll use this yet)
 025                    ;gs.yps:: .word 0	; vertical position (not sure about this either)
 026                    gs.idl:: .word 0	; insert delete mode
 027                    gs.rol:: .word 0	; roll mode
 028                    gs.bln:: .word 0	; blink mode
 029                    			; this is the first word of this screens output buff:
 030                    gs.xgp:: .word 0	; graphic X position
 031                    gs.ygp:: .word 0	; graphic Y position
 032                    gs.ldc:: .word 0	; precomputed channel select
 033                    gs.lsm:: .word 0	; precoputed  subchannel select
 034                    gs.buf:: .blkw 204	; 204 words for outputting randomly
 035           002 005  gs.lns:: .blkb lgrnl*linscr ; memory for linscr lines
 036                    	>,lgrns		; lgrns= length of a grinnel screen
 037                    
 038                    .macro grnput addr,count
 039                    	push r5
 040                    	mov t.lps+ldvadr(r0),r5
 041                    1$:	tstb 4(r5)
 042           002 041  	bpl 1$
 043                    	bit @addr,#77600	; better be ldc instr
 044                    	if ne,<	crash >
 045                    	mov addr,2(r5)
 046                    	mov count,(r5)
 047                    	tst count
 048                    	if pl,< crash >
 049                    	cmp count,#-100.
 050                    	if lt,< crash >
 051                    	mov #1,4(r5)
 052                    	pop r5
 053                    .endm
 054                    
 055           002 005  gllas:	.rept linscr	Grinnel Data Definitions                                          GRINEL.PAL[GRN,CBF] 12/19/79   Page 2.1
 056           002 004  	  .word gi.lla+764-<linspc*.rpcnt>
 057                    	.endr
 058           002 006  glles:	.rept chrlin
 059           001 031  	  .word gi.lea+<6*.rpcnt>
 060                    	.endr	DRV11-B Initialization                                            GRINEL.PAL[GRN,CBF] 12/19/79   Page 3
 001                    
 002                    .sbttl DRV11-B Initialization
 003                    
 004                    ; GRNINI - initialize DRV11-B
 005                    ;  r1 -> Initial Line Parameter Structure
 006                    ;  r2 -> Input TCB
 007                    ;  r3 -> Output TCB
 008                    
 009                    drvini:	return			; no init needed until we start using ints
 010                    
 011                    ;	push r4,r0		; save some regs
 012                    ;	mov idvadr(r1),r4	; device register address
 013                    ;	mov pc,-(sp)		; set interrupt vector
 014                    ;	add #drvint-.,(sp)
 015                    ;	mov (sp)+,-2(r3)	; set for output TCB only
 016                    				; there may not be an input TCB
 017                    ;	tst iunit(r1)		; is this the first unit (unit 0)?
 018                    	Grinnel Execution                                                 GRINEL.PAL[GRN,CBF] 12/19/79   Page 4
 001                    
 002                    .sbttl Grinnel Execution
 003                    
 004                    grnin:	jsr pc,sleep		; better never wake up again, there is no
 005                    				; grinnel input
 006                    	bpt
 007           004 004  	br grnin
 008                    
 009                    
 010                    grnout:	push #lgrns/2,#0	; ALLOC args: N_words, process id (not used)
 011                    	call alloc		; allocate grinnel screen storage and stuff
 012                    	pop r2,*		; get ptr to our storage, error code
 013                    	if ne,< crash >		; no more storage, tell someone
 014                    
 015                    	; compute up a load channel and load subchannel
 016                    	mov t.lps+ldvpar(r0),r5	; device parameter word is connector number
 017                    	sub #10.,r5		; connector numbering starts at 10.
 018                    	div #4,r4		; 4 subchannels per channel, div yields
 019                    				; channel in r4, subchannel in r5
 020                    	mov #1,r1		; make into mask
 021                    	ash r4,r1
 022  001 039           	add #gi.ldc,r1		; load channel instruction
 023           002 032  	mov r1,gs.ldc(r2)	; save it
 024                    	mov #1,r1		; make into mask
 025                    	ash r5,r1
 026  001 005           	add #gi.lsm,r1		; load subchannel instruction
 027           002 033  	mov r1,gs.lsm(r2)	; save it
 028                    	mov r2,r1
 029  002 034           	add #gs.buf,r1
 030  001 044           	mov #gi.spd+%spbyt,(r1)+ ; Set peripheral device for byte unpacking
 031  001 012           	mov #gi.lwm+%wmvec,(r1)+ ; Load Write Modes for vectors not rectangles
 032  001 017           	mov #gi.lum+2,(r1)+	; Load update mode, Ea <- Ea + Eb
 033  001 032           	mov #gi.leb+6,(r1)+	; Eb <- 6 (chars are 6 wide)
 034  001 022           	mov #gi.ers,(r1)+	; incidentally, we'd like to erase this screen
 035                    	sub r2,r1		; get difference
 036  002 032           	sub #gs.ldc,r1		; from gs.ldc
 037                    	asr r1			; divide by 2 for word count
 038                    	neg r1			; 2's complement word count
 039                    	mov r2,r4
 040  002 032           	add #gs.ldc,r4
 041  002 038           	grnput r4,r1		; grnput address, count
 042           004 047  	jsr pc,grini		; initialize things
 043           005 011  	jmp grloop
 044                    
 045                    
 046                    	; intialize line image
 047                    grini:	push r1,r5
 048                    	clr r4			; r4 will count the line number
 049                    	mov r2,r3		; get pointer to array of lines
 050  002 035           	add #gs.lns,r3
 051                    loop <	  ; r4 is line number counts up from 0
 052                    	  ; r3 is pointer to array of lines increments continuously
 053  002 032           	  mov gs.ldc(r2),(r3)+	; each line is a select channel
 054  002 033           	  mov gs.lsm(r2),(r3)+	; followed by a select subchannel
 055                    	  mov r4,r1		; current line number	Grinnel Execution                                                 GRINEL.PAL[GRN,CBF] 12/19/79   Page 4.1
 056                    	  add r1,r1		; make word offset
 057  002 055           	  mov gllas(r1),(r3)+	; index into precomputed LLAs
 058  001 031           	  mov #gi.lea,(r3)+	; followed by a load horizontal
 059  001 044           	  mov #gi.spd+%spbyt,(r3)+ ; select byte unpack "peripheral"
 060  002 006           	  mov #gi.lpr+%lpbyt+%lpbys+%lpode+<chrlin+1/2>,(r3)+
 061                    				; select byte unpack with odd end
 062                    	  mov r4,r1		; get line number
 063                    	  add r1,r1		; convert to word index
 064                    	  add r2,r1		; to base of grinnell screen structure
 065           002 023  	  mov r3,gs.lin(r1)	; store pointer to line of characters
 066  002 006           	  mov #chrlin,r5	; 85. chars per line
 067                      loop <    movb #40,(r3)+	; store out space for line
 068                    	    sorl r5
 069                    	    >
 070                    	  .if ne 0
 071                    	  cmp r4,#25.		; was this line 25?
 072                    	  if eq,<		; if it was put a C<channel #>,S<subchan #>
 073                    	    movb #'C,-45.(r3)	;  in the middle of the screen!
 074  002 032           	    movb gs.ldc(r2),-(sp)
 075                    	    add #60,(sp)
 076                    	    movb (sp)+,-44.(r3)
 077                    	    movb #'S,-43.(r3)
 078  002 033           	    movb gs.lsm(r2),-(sp)
 079                    	    add #60,(sp)
 080                    	    movb (sp)+,-42.(r3)
 081                    	    >
 082                    	  .endc
 083                    	  mov (r1),r1		; ref through ptr to line
 084  002 010           	  sub #gl.chr-gl.ldc,r1	; make it ptr to grinnell instr instead of chr
 085  002 038           	  grnput r1,#-lgrnl/2	; output each line as its built
 086                    	  bit #1,r3		; .even r3
 087                    	  if ne,<
 088                    	    inc r3
 089                    	    >
 090                    	  inc r4		; advance line number
 091           002 005  	  cmp r4,#linscr	; done all the lines yet?
 092                    	  rptl lo		; exit when r4 grtr lines per screen
 093                    	  >
 094                    
 095                    	; initialize screen params
 096                    ;	clr gs.xps
 097                    ;	clr gs.yps
 098                    	clr r3
 099                    	clr r4
 100                    	; this sequence of code computes R3 and R4 from gs.xps, gs.yps
 101                    ;	mov gs.yps(r2),r3
 102                    ;	add r3,r3
 103                    ;	add r2,r3
 104  002 023           .iif ne	  gs.lin, .error "GS.LIN assumed 0 here"
 105                    ;	mov (r3),r4
 106                    ;	add gs.xps(r2),r4
 107                    	pop r5,r1
 108                    	rts pc	Grinnell main loop                                                GRINEL.PAL[GRN,CBF] 12/19/79   Page 5
 001                    
 002                    .sbttl	Grinnell main loop
 003                    
 004                    ; R0 -> TCB as usual
 005                    ; R1 -> usually current character
 006                    ; R2 -> Grinnell screen structure
 007                    ; R3 -> 2*line number  (R3+R2) should index into ptrs to lines
 008                    ; R4 -> Y pos of character
 009                    ; R5 -> general temp
 010                    
 011                    grloop:	call getchr
 012                    grl1:	bic #177600,r1		; no need for random parity
 013                    	cmp r1,#177		; throw padding away
 014           005 011  	beq grloop
 015                    	cmp r1,#40
 016                    	if lo,<
 017                    	  mov pc,r5
 018  005 273           	  add #grdisp-.,r5
 019                    	  add r1,r5
 020                    	  add r1,r5
 021                    	  add (r5),r5
 022                    	  jsr pc,(r5)
 023           005 011  	  br grloop
 024                    	  >
 025           005 028  	jsr pc,grordy
 026           005 011  	br grloop
 027                    
 028           002 006  grordy:	cmp r4,#chrlin		; overflow case?
 029                    	if hi,<			; overflow
 030                    	  tst (r3)+		; move to next line
 031           002 005  	  cmp r3,#<linscr*2>-2	; bottom of screen?
 032                    	  if his,<
 033                    	    clr r3		; wrap to top
 034                    	    >
 035                    	  clr r4		; column zero
 036                    	  >
 037                    	mov r2,r5		; base address of line array
 038                    	add r3,r5		; index by line
 039                    	mov (r5),r5		; pointer to a line
 040                    	add r4,r5		; to a char
 041                    	movb r1,(r5)		; store character
 042  002 055  002 034  	mov gllas(r3),gs.buf(r2)
 043                    	asl r4			; word offset
 044  002 058  002 034  	mov glles(r4),gs.buf+2(r2)
 045                    	asr r4			; back to bytes
 046  001 007           	add #gi.wac,r1		; make a write alpha char instruction
 047           002 034  	mov r1,gs.buf+4(r2)
 048                    	push r4
 049                    	mov r2,r4
 050  002 032           	add #gs.ldc,r4
 051  002 038           	grnput r4,#-5
 052                    	pop r4
 053                    	inc r4			; advance the cursor (wow!)
 054                    	rts pc
 055                    	Grinnell main loop                                                GRINEL.PAL[GRN,CBF] 12/19/79   Page 5.1
 056           002 026  grup:	tst gs.idl(r2)		; insert/delete mode?
 057                    	if eq,<			; no
 058                    	  tst r3		; top line?
 059                    	  if eq,<
 060                    	    rts pc
 061                    	    >
 062                    	  tst -(r3)		; up a line, subtract 2
 063                    	  rts pc
 064                    	  >
 065                    	; delete line
 066                    	push r3			; save current line number
 067                    	mov r3,r5		; copy line index
 068                    	add r2,r5		; pointer to array of line pointers
 069                    	push (r5)		; save this line!
 070  002 023           .iif ne gs.lin,  .error "GS.LIN assumed 0 here"
 071           002 005  loop <	  cmp r3,#<linscr*2>-2	; we done?
 072                    	  exitl his
 073                    	  mov 2(r5),(r5)	; slide this line up
 074                    	  mov (r5),r1		; get pointer to this line
 075  002 055  002 017  	  mov gllas(r3),gl.lla-gl.chr(r1) ; update LLA (X pos) for this line
 076  002 010           	  sub #gl.chr-gl.ldc,r1	; point r1 at grinnell instructions
 077  002 038           	  grnput r1,#-lgrnl/2	; output line
 078                    	  tst (r3)+		; advance line count
 079                    	  tst (r5)+		; advance line pointer
 080                    	  rptl
 081                    	  >
 082                    	pop (r5)		; put this line back
 083                    	push r4			; save h pos
 084                    	clr r4			; clear out whole line
 085           005 178  	jsr pc,greol
 086                    	pop r4			; restore hpos
 087                    	pop r3			; restore our line pos (x pos)
 088                    	rts pc
 089                    
 090           002 026  grlf:	tst gs.idl(r2)		; insert/delete mode?
 091                    	if eq,<			; no
 092           002 005  	  cmp r3,#<linscr*2>-2	;  on last line?
 093                    	  if lo,<		;   no
 094                    	    tst (r3)+
 095                    	    rts pc
 096                    	    >			;  otherwise, we are on last line..
 097           002 027  	  tst gs.rol(r2)	;  roll mode?
 098                    	  if eq,<		;   no
 099                    	    clr r3		;   go to top line
 100                    	    >			;  else we are in roll mode, on last line..
 101                    	  ; roll mode not implemented	  
 102                    	  rts pc
 103                    	  >			; else, we were in insert/delte mode..
 104           002 005  	cmp r1,#<linscr*2>-2	; meaningless on last line
 105                    	if his,< rts pc >
 106                    	push r3			; save current line number
 107                    	mov r3,r5		; copy line index
 108                    	add r2,r5		; pointer to array of line pointers
 109                    	mov (r5),-(sp)		; save current line
 110  002 005           	mov linscr*2-2(r2),(r5)+	Grinnell main loop                                                GRINEL.PAL[GRN,CBF] 12/19/79   Page 5.2
 111  002 023           .iif ne gs.lin,  .error "GS.LIN assumed 0 here"
 112                    	push r5,r4
 113                    	clr r4
 114           005 178  	jsr pc,greol
 115                    	pop r4,r5
 116                    loop <	  tst (r3)+		; move r3 to next line
 117                    	  mov (r5),r1		; make next line current line
 118                    	  mov (sp),(r5)		; put previous line into it
 119                    	  mov r1,(sp)		; and make current line next line
 120                    	  mov (r5)+,r1		; get pointer to this line
 121  002 055  002 017  	  mov gllas(r3),gl.lla-gl.chr(r1) ; update LLA (X pos) for this line
 122  002 010           	  sub #gl.chr-gl.ldc,r1	; point r1 at grinnell instructions
 123  002 038           	  grnput r1,#-lgrnl/2	; output line
 124           002 005  	  cmp r3,#<linscr*2>-2	; we done
 125                    	  exitl his
 126                    	  rptl
 127                    	  >
 128                    	tst (sp)+		; throw away last saved line pos
 129                    	pop r3			; restore our line pos
 130                    	rts pc
 131                    
 132           002 026  grbs:	tst gs.idl(r2)		; insert/delete mode?
 133                    	if eq,<			; no
 134                    	  tst r4		; column 0?
 135                    	  if hi,<
 136                    	    dec r4
 137                    	    >
 138                    	  rts pc
 139                    	  >
 140                    	; insert delete not implemented
 141                    	rts pc
 142                    
 143           002 026  grrt:	tst gs.idl(r2)		; insert/delete?
 144                    	if eq,<			; no
 145           002 006  	  cmp r4,#chrlin	; overflow off right margin?
 146                    	  if lo,<		; no
 147                    	    inc r4		; inscrease X-Pos
 148                    	    rts pc
 149                    	    >
 150                    	  clr r4		; wrap off right to next line
 151                    	  tst (r3)+
 152           002 005  	  cmp r3,#linscr*2	; bottom line?
 153                    	  if his,<
 154                    	    clr r3
 155                    	    >
 156                    	  rts pc
 157                    	  >
 158                    	; insert delete case not implmented
 159                    	rts pc
 160                    
 161                    grcr:	clr r4			; CR - 0 col
 162                    	rts pc			; don't auto-NL
 163                    
 164                    grhom:	clr r3			; clr Y
 165                    	clr r4			; clr X	Grinnell main loop                                                GRINEL.PAL[GRN,CBF] 12/19/79   Page 5.3
 166           005 167  	br grrst
 167                    
 168                    grcan:				; fall through to dm reset..
 169           002 026  grrst:	clr gs.idl(r2)		; clear insert/delete mode
 170           002 027  	clr gs.rol(r2)		; clear roll mode
 171           002 028  	clr gs.bln(r2)		; clear blink/bold or whatever
 172                    	rts pc
 173                    
 174                    grbel:	; gee what do we do for a bell?
 175                    	rts pc
 176                    
 177           002 026  gri.d:	mov pc,gs.idl(r2)	; set insert delete mode
 178                    	rts pc
 179                    
 180                    greol:	mov r2,r5		; base of grinnell screen structre
 181  002 023           .iif ne gs.lin,  .error "GS.LIN assumed 0 here"
 182                    	add r3,r5		; index into GS.LIN
 183                    	mov (r5),r5		; get ptr to a line
 184  002 055  002 017  	mov gllas(r3),gl.lla-gl.chr(r5) ; make sure the LLA command is accurat
 185  001 031  002 017  	mov #gi.lea,gl.lea-gl.chr(r5) ; and lea command
 186                    	push r5			; save it
 187                    	mov #20040,r1		; preload blanks outside of loop
 188                    	mov r4,-(sp)		; copy column addr for munging
 189                    	add r4,r5		; offset to current char
 190                    	bit #1,r4		; odd address?
 191                    	if ne,<			; yes,
 192                    	  movb r1,(r5)+		; bring address to an even boundary
 193                    	  inc (sp)
 194                    	  >
 195                    	add (sp)+,pc
 196           002 006  	.rept chrlin/2
 197                    	  mov r1,(r5)+
 198                    	.endr
 199           002 006  	.lif ne chrlin&1	; odd number of bytes per line?
 200                    	movb r1,(r5)+		; clear out last byte
 201                    	pop r5
 202                    	push r3
 203                    	mov r5,r3
 204  002 010           	sub #gl.chr-gl.ldc,r3	; point to start of line
 205  002 038           	grnput r3,#-lgrnl/2	; output the line
 206                    	pop r3
 207                    	rts pc
 208                    
 209                    ; Waits seem to think that EOS and MR should be equivelant
 210           005 253  greos:	jmp grmr
 211                    ;	rts pc
 212                    
 213                    grstab: ; not implemented yet
 214                    	rts pc
 215                    
 216                    grctab:	; not implemented yet
 217                    	rts pc
 218                    
 219                    grtab:	bic #7,r4
 220                    	add #10,r4	Grinnell main loop                                                GRINEL.PAL[GRN,CBF] 12/19/79   Page 5.4
 221           002 006  	cmp r4,#chrlin
 222                    	if hi,<
 223  002 006           	  mov #chrlin,r4
 224                    	  >
 225                    	rts pc
 226                    	
 227                    gradr:	call getchr		; get row address
 228                    	bic #177600,r1
 229                    	cmp #30,r1		; CAN?
 230                    	if eq,<
 231                    	  pop *
 232           005 166  	  jmp grcan
 233                    	  >
 234                    	cmp #2,r1
 235                    	if eq,<
 236                    	  pop *
 237           005 162  	  jmp grhom
 238                    	  >
 239                    	mov r1,-(sp)
 240                    	mov #140,r1
 241                    	xor r1,(sp)
 242                    	mov (sp)+,r1
 243                    	rts pc
 244                    
 245           005 224  grabs:	jsr pc,gradr		; get Hpos (col) X
 246                    	mov r1,r5		; holding bin, don't smash until we get both
 247           005 224  	jsr pc,gradr		; get Line # (row) Y
 248                    	mov r1,r3
 249                    	add r3,r3		; Line # is always times two
 250                    	mov r5,r4		; Hpos
 251                    	rts pc
 252                    
 253           002 027  grron:	mov pc,gs.rol(r2)
 254                    	rts pc
 255                    
 256           004 047  grmr:	jsr pc,grini		; reinitialize everything
 257                    	call getchr		; Check for either 2 Master resets in a row
 258                    	cmp r1,#36		; or an MR followed by a Clear EOS.
 259           002 041  	beq 1$			; Sending the command twice is apparently
 260                    	cmp r1,#37		; a standard way of padding the function
 261           002 041  	beq 1$			; on DMs.
 262                    	tst (sp)+		; throw away our return addr
 263           005 012  	jmp grl1		; and proceed immediately to dispatch
 264                    1$:	rts pc
 265                    
 266           002 028  grbln:	mov pc,gs.bln(r2)
 267                    	rts pc
 268                    
 269                    gresc:	call getchr
 270                    	bic #177600,r1
 271           005 028  	jsr pc,grordy
 272                    	rts pc
 273                    
 274                    grjunk:	rts pc
 275                    	Grinnell main loop                                                GRINEL.PAL[GRN,CBF] 12/19/79   Page 5.5
 276           005 271  grdisp:	grjunk-.	; 00 ^@
 277           005 271  	grjunk-.	; 01 ^A
 278           005 162  	grhom-.		; 02 ^B Home
 279           005 271  	grjunk-.	; 03 ^C
 280           005 271  	grjunk-.	; 04 ^D
 281           005 271  	grjunk-.	; 05 ^E
 282           005 271  	grjunk-.	; 06 ^F
 283           005 172  	grbel-.		; 07 ^G Bell
 284           005 130  	grbs-.		; 10 ^H Backspace - Right Cursor
 285           005 216  	grtab-.		; 11 ^I Tab
 286           005 089  	grlf-.		; 12 ^J Linefeed - Down Cursor
 287           005 213  	grctab-.	; 13 ^K Clear Tab
 288           005 242  	grabs-.		; 14 ^L Absolute Move
 289           005 159  	grcr-.		; 15 ^M Carriage Return
 290           005 263  	grbln-.		; 16 ^N Blink On
 291           005 271  	grjunk-.	; 17 ^O Form On
 292           005 175  	gri.d-.		; 20 ^P Insert/Delete
 293           005 271  	grjunk-.	; 21 ^Q Xmit Page
 294           005 271  	grjunk-.	; 22 ^R Print
 295           005 271  	grjunk-.	; 23 ^S Xmit Line
 296           006 004  	grgraf-.	; 24 ^T S-1 Graphics protocol
 297           005 271  	grjunk-.	; 25 ^U
 298           005 271  	grjunk-.	; 26 ^V
 299           005 178  	greol-.		; 27 ^W Erase to end of Line
 300           005 166  	grcan-.		; 30 ^X Cancel
 301           005 210  	grstab-.       	; 31 ^Y Tab Set
 302           005 056  	grup-.		; 32 ^Z Up Cursor
 303           005 266  	gresc-.		; 33 ^[
 304           005 141  	grrt-.		; 34 ^\ Right Cursor
 305           005 250  	grron-.		; 35 ^] Roll Mode on
 306           005 253  	grmr-.		; 36 ^^ Master Rest
 307           005 207  	greos-.		; 37 ^_ Erase to end of Screen	Graphics                                                          GRINEL.PAL[GRN,CBF] 12/19/79   Page 6
 001                    
 002                    	.sbttl Graphics
 003                    
 004                    grgraf:	push r3,r4		; R1 and R5 are smashable anyway
 005           006 171  1$:	call gfxget		; get a char
 006                    	cmp r1,#11		; check for range of graphics commands
 007                    	if hi,<			; flush if out of range
 008                    	  pop r3,r4
 009           005 011  	  jmp grloop
 010                    	  >
 011                    	asl r1			; make word offset
 012           006 013  	jmp @gfxdsp(r1)		; vector
 013           006 024  gfxdsp:	gfxnop		; graphics no-op
 014           006 027  	gfxabs		; graphics absolute move
 015           006 032  	gfxrli		; graphics relative move, invisible
 016           006 059  	gfxrlv		; graphics relative move, visible
 017           006 088  	gfxhzs		; graphics horizontal string
 018           006 123  	gfxvts		; graphics vertical string
 019           006 024  	gfxnop		; graphics "channel select"
 020           006 160  	gfxscs		; graphics set character size
 021           006 163  	gfxclr		; graphics clear screen
 022           006 042  	gfxfast		; graphics high efficiency relative move mode
 023                    
 024                    gfxnop:	pop r4,r3
 025                    	rts pc
 026                    
 027           006 178  gfxabs:	call gfxpos		; get a position
 028           002 030  	mov r3,gs.xgp(r2)	; store it in X graphics position
 029           002 031  	mov r4,gs.ygp(r2)	; and Y graphics position
 030           006 024  	br gfxnop		; return
 031                    
 032           006 178  gfxrli:	call gfxpos		; get a position
 033           002 030  	add r3,gs.xgp(r2)	; Update X graphics position
 034           002 031  	add r4,gs.ygp(r2)	; update Y graphics position
 035           006 024  	br gfxnop
 036                    
 037                    
 038                    ; GFXFAST -high speed incremental graphics mode. Eats all subsequent
 039                    ; characters in the range 40>=chr>140.  6 bits of data are then taken as
 040                    ; 3 bits signed X offset in high order and 3 bits signed Y offset in
 041                    ; low order
 042                    gfxfast:
 043                    	call getchr		; get a character
 044                    	sub #40,r1		; map it down
 045           006 024  	blt gfxnop		; exit mode at first char not in range
 046                    	cmp r1,#100
 047           006 024  	bge gfxnop
 048                    	mov r1,r4		; get Y difference
 049                    	bic #177770,r4
 050                    	ash #13.,r4		; extend sign
 051                    	ash #-13.,r4
 052                    	mov r1,r3		; get X difference
 053                    	bic #177707,r3
 054                    	ash #10.,r3		; extend sign
 055                    	ash #-13.,r3	Graphics                                                          GRINEL.PAL[GRN,CBF] 12/19/79   Page 6.1
 056           006 063  	jsr pc,grelit
 057                    	br gfxfas
 058                    
 059           006 178  gfxrlv:	call gfxpos		; get a position
 060           006 063  	jsr pc,grelit		; do the Rel ptr
 061           006 024  	br gfxnop
 062                    
 063                    grelit:	mov r2,r1		; get a pointer to our buffer
 064  002 034           	add #gs.buf,r1
 065  002 031           	mov gs.ygp(r2),r5
 066                    	bic #177000,r5
 067  001 035           	add #gi.lla,r5
 068                    	mov r5,(r1)+
 069  002 030           	mov gs.xgp(r2),r5
 070                    	bic #177000,r5
 071  001 031           	add #gi.lea,r5
 072                    	mov r5,(r1)+
 073           002 030  	add r3,gs.xgp(r2)
 074           002 031  	add r4,gs.ygp(r2)
 075                    	bic #177000,r3
 076  001 032           	add #gi.leb,r3
 077                    	mov r3,(r1)+
 078                    	bic #177000,r4
 079  001 029           	add #gi.llb+%lrfgw,r4	; do the graphic write operation here
 080                    	mov r4,(r1)+
 081  001 032           	mov #gi.leb+6,(r1)+	; restore the character stepping
 082  001 036           	mov #gi.llb,(r1)+
 083                    	mov r2,r1
 084  002 032           	add #gs.ldc,r1
 085  002 038           	grnput r1,#-8		; do it
 086                    	rts pc
 087                    
 088                    gfxhzs:	mov r2,r4		; get a pointer to the buffer
 089  002 034           	add #gs.buf,r4
 090                    	call getchr		; get count
 091                    	bic #177600,r1
 092                    	sub #40,r1
 093           006 024  	ble gfxnop
 094                    	mov r1,r3		; count in r3
 095  001 017           	mov #gi.lum+2,(r4)+	; set update mode for horizontal
 096  001 010           	mov #gi.lwm+%wmvec+%wmor,(r4)+	; inclusive or
 097  002 031           	mov gs.ygp(r2),r1	; position Y
 098                    	bic #177000,r1
 099  001 035           	add #gi.lla,r1
 100                    	mov r1,(r4)+
 101  002 030           	mov gs.xgp(r2),r1	; position X
 102                    	bic #177000,r1
 103  001 031           	add #gi.lea,r1
 104                    	mov r1,(r4)+
 105  001 032           	mov #gi.leb+6,(r4)+	;  Eb of 6
 106                    loop <	  call getchr		; read the chars
 107                    	  bic #177600,r1
 108           002 030  	  add #6,gs.xgp(r2)	; update permanent X position
 109  001 007           	  add #gi.wac,r1	; make into a Load Alphanumeric char instr
 110                    	  mov r1,(r4)+	Graphics                                                          GRINEL.PAL[GRN,CBF] 12/19/79   Page 6.2
 111                    	  sorl r3
 112                    	  >
 113  001 012           	mov #gi.lwm+%wmvec,(r4)+ ; clear all the modes
 114  002 032           	sub #gs.ldc,r4		; figure out how much we put in buffer
 115                    	sub r2,r4
 116                    	asr r4			; word count
 117                    	neg r4			; twos complement
 118                    	mov r2,r3
 119  002 032           	add #gs.ldc,r3
 120  002 038           	grnput r3,r4
 121           006 024  gfxnp1:	jmp gfxnop
 122                    
 123                    gfxvts:	mov r2,r4		; get a pointer to the buffer
 124  002 034           	add #gs.buf,r4
 125                    	call getchr		; get count
 126                    	bic #177600,r1
 127                    	sub #40,r1
 128           006 121  	ble gfxnp1
 129                    	mov r1,r3		; count in r3
 130  001 017           	mov #gi.lum+10,(r4)+	; set update mode for horizontal
 131  001 010           	mov #gi.lwm+%wmvec+%wmor,(r4)+	; inclusive or
 132  002 031           	mov gs.ygp(r2),r1	; position Y
 133                    	bic #177000,r1
 134  001 035           	add #gi.lla,r1
 135                    	mov r1,(r4)+
 136  002 030           	mov gs.xgp(r2),r1	; position Y
 137                    	bic #177000,r1
 138  001 031           	add #gi.lea,r1
 139                    	mov r1,(r4)+
 140  001 036           	mov #gi.llb+<777&-12.>,(r4)+	;  Lb of -12.
 141                    loop <	  call getchr		; read the chars
 142                    	  bic #177600,r1
 143           002 031  	  sub #12.,gs.ygp(r2)	; increment permanent Y position
 144  001 007           	  add #gi.wac,r1	; make into a Load Alphanumeric char instr
 145                    	  mov r1,(r4)+
 146                    	  sorl r3
 147                    	  >
 148  001 012           	mov #gi.lwm+%wmvec,(r4)+	; clear all the modes
 149  001 017           	mov #gi.lum+2,(r4)+	; back to normal
 150  001 036           	mov #gi.llb,(r4)+
 151  002 032           	sub #gs.ldc,r4		; figure out how much we put in buffer
 152                    	sub r2,r4
 153                    	asr r4			; word count
 154                    	neg r4			; twos complement
 155                    	mov r2,r3
 156  002 032           	add #gs.ldc,r3
 157  002 038           	grnput r3,r4
 158           006 024  	jmp gfxnop
 159                    
 160                    gfxscs:	call getchr
 161           006 024  	jmp gfxnop
 162                    
 163                    gfxclr:	mov r2,r4		; get pointer to buf
 164  002 034           	add #gs.buf,r4
 165  001 022           	mov #gi.ers,(r4)	Graphics                                                          GRINEL.PAL[GRN,CBF] 12/19/79   Page 6.3
 166                    	sub #4,r4
 167  002 038           	grnput r4,#-3
 168           006 024  	jmp gfxnop
 169                    
 170                    ; GFXGET - read in a character, drop it by 40 and reject control chars
 171                    gfxget:	call getchr		; get Graphic op code
 172                    	bic #177600,r1		; mask down to 7 bits
 173                    	sub #40,r1		; ignore chars less than 40 for stupid systems
 174           006 171  	blt gfxget		; that insert CRLF's and the like
 175                    	return
 176                    
 177                    ; GFXPOS - reads in 4 chars and puts Xh,Xl in R3 and Yh,Yl in R4
 178           006 171  gfxpos:	call gfxget		; get Xh
 179                    	ash #10.,r1		; over by 10.
 180                    	ash #-4,r1		; and back by 4 to accomplish sign extension
 181                    	mov r1,r3
 182           006 171  	call gfxget		; get Xl
 183                    	bis r1,r3
 184           006 171  	call gfxget		; Yh
 185                    	ash #10.,r1		; over by 10.
 186                    	ash #-4,r1		; and back by 4 to accomplsih sign extension
 187                    	mov r1,r4
 188           006 171  	call gfxget		; Yl
 189                    	bis r1,r4
 190                    	return
 191                    
 192                    
 193                    
 194                    Symbol Table for:    GRINEL.PAL[GRN,CBF]                                     12/19/79   Page I
                     

%LPBYS  = 001 053   1$ ....   005 261   GI.LDC  = 001 039   GI.SPD  = 001 042   GRCR ..   005 159   GRORDY    005 028 
%LPBYT  = 001 050   1$ ....   006 005   GI.LEA  = 001 031   GI.WAC  = 001 007   GRCTAB    005 213   GRRON     005 250 
%LPGRA  = 001*051   CHRLIN  = 002 006   GI.LEB  = 001 032   GI.WGD  = 001*006   GRDISP    005 273   GRRST     005 167 
%LPIMA  = 001*052   DRVINI    003*009   GI.LEC  = 001*033   GI.WID  = 001*004   GRELIT    006 063   GRRT ..   005 141 
%LPODE  = 001 054   GFXABS    006 027   GI.LER  = 001*030   GL.CHR    002 017   GREOL     005 178   GRSTAB    005 210 
%LRFGW  = 001 029   GFXCLR    006 163   GI.LLA  = 001 035   GL.LDC    002 010   GREOS     005 207   GRTAB     005 216 
%SMFSC  = 001*026   GFXDSP    006 013   GI.LLB  = 001 036   GL.LEA    002 013   GRESC     005 266   GRUP ..   005 056 
%SPBYT  = 001 044   GFXFAST   006 042   GI.LLC  = 001*037   GL.LLA    002 012   GRGRAF    006 004   GS.BLN    002 028 
%SPINT  = 001*045   GFXGET    006 171   GI.LLR  = 001*034   GL.LPR    002*016   GRHOM     005 162   GS.BUF    002 034 
%SPMRD  = 001*043   GFXHZS    006 088   GI.LPA  = 001*048   GL.LSM    002*011   GRI.D     005 175   GS.IDL    002 026 
%SPTST  = 001*046   GFXNOP    006 024   GI.LPD  = 001*057   GL.SPD    002*014   GRINI     004 047   GS.LDC    002 032 
%WM2HI  = 001*013   GFXNP1    006 121   GI.LPR  = 001 049   GLLAS     002 055   GRJUNK    005 271   GS.LIN    002 023 
%WM2WI  = 001*014   GFXPOS    006 178   GI.LSM  = 001 005   GLLES     002 058   GRL1 ..   005 012   GS.LNS    002 035 
%WMCSO  = 001*016   GFXRLI    006 032   GI.LUM  = 001 017   GRABS     005 242   GRLF ..   005 089   GS.LSM    002 033 
%WMINV  = 001*009   GFXRLV    006 059   GI.LWM  = 001 008   GRADR     005 224   GRLOOP    005 011   GS.ROL    002 027 
%WMOR   = 001 010   GFXSCS    006 160   GI.NOP  = 001*060   GRBEL     005 172   GRMR ..   005 253   GS.XGP    002 030 
%WMSCS  = 001*015   GFXVTS    006 123   GI.NP1  = 001*040   GRBLN     005 263   GRNIN     004 004   GS.YGP    002 031 
%WMSUB  = 001*011   GI.EGW  = 001*027   GI.RPD  = 001*058   GRBS ..   005 130   GRNOUT    004*010   LINSCR  = 002 005 
%WMVEC  = 001 012   GI.ERL  = 001*023   GI.SLU  = 001*024   GRCAN     005 166   GRNPUT  M 002 038   LINSPC  = 002 004 
1$ ....   002 041   GI.ERS  = 001 022   