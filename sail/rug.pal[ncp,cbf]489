; RUG - PDP11 SYMBOLIC DEBUGGER   -*-PALX-*-
versio==%fnam2

.TITLE RUG


;;; SETF macro for asking questions at assembly time.

.macro	setf q,a
  .if ndf  a
	.print "q "
	.ttymac ans
	  .if ndf  ans
	    setf ^"Bad input, try again:",a
	    .mexit
	  .endc
	  a==ans
	.endm
  .endc
.endm

; Define YES and NO so they're acceptable SETF answers
yes===1
no===0


$$pic===0
.insrt defs


setf ^"Start of RUG?",rugsa
.iif eq memman, asmmap===0
setf ^"Use mapping?",asmmap

setf ^"RT11?",asmrt1
setf ^"Serial line?",asmsrl

.lif ne asmrt1+asmsrl
  setf ^"Program Dumping?",asmdmp

.iif ndf asmRT1, asmRT1==0
.iif ndf asmsrl, asmsrl==0
.iif ndf asmdmp, asmdmp==0
.iif ndf asmttp, asmttp==0

setf ^"Terminal address (0=177560)?",trs
.iif eq trs, trs==177560

.if ne asmrt1
setf ^"Console interrupt vector (0=60)?",icvec
.iif eq icvec, icvec==60
.endc

; terminal type codes
%tngl==-1	; Glass		Note, comparisons depend on Glass being
%tntt==0	; TTY		less than 0 and TTY being 0.
%tnsb==1	; StupidBee
%tnvt==2	; VT52


.macro	printc c
	jsr r5,ctypec
	  .word c
.endm

.macro	print text
	jsr r5,types
	  .string ^~text~
.endm

.macro	sout text
	jsr r5,itypes
	  .string ^~text~
.endm


nbpt==10		;number of breakpoints

; flag word bits
%regv==1		; regsiter value flag bit
%half==2		; half killed
%ndef==4		; undefined expression
%nilv==10		; null expression

.sbttl	RUG Initialization


mapjmp===1000

;;; Initial start point.

.=rugsa-1000			; put initial start point below initial
				; symbol table (where it will get zero'd on
				; startup)


rug:	spl 7			; RUG runs at high priority
	mov #stack,sp		; set RUG's stack pointer
.lif ne asmrt1
	call sistat		; save inital state for RT-11
	call sstat1		; save rest of machine state, set NXM trap
				; vector
.if ne  asmmap
	call mapini
	call movrug
.endc
	call clrscn		; clear screen

	jsr r5,types
	  .word	%greet

	push #rugcmd		; same as CALL ZERO1 / JMP RUGCMD except that
	jmp zero1		; this works even after ZERO1 wipes out this
				; code

%greet===.
	.ascii "
RUG "
	.decim versio
.iif eq asmmap, %%temp===rugsa
.iif ne asmmap, %%temp===mapjmp
.irp ra,\%%temp
	.asciz ".  Restart is ra'.
"
.endm
	.even


.if ne  asmmap
kipdr==172300			; Kernel instruction space page descriptor
kipar==172340			; Kernel instruction space page address
uipdr==177600			; User instruction space page descriptor
uipar==177640			; User instruction space page address


;;; Set up identity map.

mapini:	;; initialize kernel PDRs and PARs
	mov #8,r0		; R0: number of pages
	mov #kipdr,r1		; R1: address of 1st PDR
	mov #kipar,r2		; R2: address of 1st PAR
	clr r3			; R3: block address for 1st page
loop <	  mov #177_8+6,(r1)+	; set PDR to 8K r/w page
	  mov r3,(r2)+		; set PAR for identity mapping
	  add #200,r3		; increase block address by 128 blocks (8K
	  sorl r0		; bytes)
	  >
	mov #177600,-(r2)	; map last page to device registers of Unibus
	mov #8,r0
	mov #kipar,r1
	mov #uipar,r2
loop <	  mov (r1)+,(r2)+
	  sorl r0
	  >
;	mov #20,@#172516	; set 22 bit mapping (random)
	mov #1,@#177572		; enable mapping
	return

rugvpg===<rugsa_-13.>&7		; virtual page number of RUG code
rugppg===30.			; physical page number for RUG code
winvpg===1			; virtual page number of window used by RUG
				; to examine user address space, etc.
.iif eq rugvpg-winvpg,   .error	Page assignments conflict
.iif eq rugvpg-1-winvpg, .error	Page assignments conflict

.if gt rugvpg*8192.-<rugsa-1000>
	.error Start address incompatible with mapping RUG.
	.print "                    Suggest at least "
	typval \rugvpg*8192.+1000
	.print "
"
.endc

rugpar===kipar+<rugvpg*2>	; PAR for RUGVPG
winpar===kipar+<winvpg*2>	; PAR for WINVPG

movrug:	mov #rugppg*200,@#winpar	; map physical 120-124K to virtual 4-8K
	mov #4096.,r0		; R0: number of words in page
	mov #rugvpg*8192.,r1	; R1: 1st address of page containing RUG
	mov #winvpg*8192.,r2	; R2: 1st address of window page
loop <	  mov (r1)+,(r2)+	; copy RUG to physical 120-124K
	  sorl r0		; ...
	  >
	mov #rugppg*200,@#rugpar	; switch to 120-124K RUG code
	mov #<rugppg-1>*200,@#rugpar-2	; map 116-120K for RUG symbols
	return


;;; Trap handlers to get to map in RUG and then transfer to it.

.=mapjmp
reentr:	mov #restrt,mapjra
	br mapj

trap4:	mov #trap4x,mapjra
	br mapj

bpth:	mov #bpthx,mapjra
;	br mapj

;;; (This assumes PDRs are set reasonably.)
mapj:	mov r0,(pc)+		; save r0
mapjr0:	 .blkw 1
	mov r1,(pc)+		; save r1
mapjr1:	 .blkw 1
	mov #kipar,r0		; R0: pointer to PARs
	mov #uipar,r1		; R1: pointer to PAR save area
	mov (r0),(r1)+		; save PAR0
	clr (r0)+		; map to physical page 0
.rept rugvpg-2
	mov (r0)+,(r1)+		; save from PAR1 to PAR<n-2>
.endr
	mov (r0),(r1)+		; save PAR<n-1>
	mov #<rugppg-1>*200,(r0)+	; map RUG symbol table
	mov (r0),(r1)+		; save PARn
	mov #rugppg*200,(r0)+	; map RUG code
.rept 6-rugvpg
	mov (r0)+,(r1)+		; save PAR<n+1> to PAR6
.endr
	mov (r0),(r1)+		; save PAR7
	mov #177600,(r0)	; map device registers
	mov @#177572,mapenb	; save mapping enable
	mov #1,@#177572		; enable mapping
	jmp @mapjra		; enter RUG


contx:	mov #uipar,r0		; R0: PAR save area address
	mov #kipar,r1		; R1: PAR address
.rept 8
	mov (r0)+,(r1)+		; restore PAR
.endr
	mov mapenb,@#177572	; restore map enable
	mov (pc)+,r1		; restore R1
mapcr1:	 .blkw 1
	mov (pc)+,r0		; restore R0
mapcr0:	 .blkw 1
	rtt			; continue program

mapjra:	.blkw 1			; RUG address to transfer to after map
				; hackery
mapenb:	.word 0			; mapping enable register save area

mapjen::

.if p2
	.print "
MAPJEN = "
	typval \mapjen
.endc
.endc	; ne asmmap

;;; Restart entry point.  This starts RUG saving all the machine state
;;; available.

.=rugsa				; restart at first address to make it easy to
				; remember

restrt:	;; save processor status word
.if df  ps
	mov @#ps,ups		; get high byte if there is one
.iff
	mfps ups		; otherwise use instruction
.endc
	spl 7			; set high priority
	mov sp,usp		; save stack ptr
	clr upc			; clear PC since its unknown
	mov #stack,sp		; setup RUG's stack
	call sstat		; save program state, set up RUG state
	tst bptset		; breakpoints set?
	if ne,<			; yes
	  call rembrk		; remove breakpoints
	  >
	mov #-1,bptno		; indicate not stopped at breakpoint
;	br rugcmd

.sbttl	RUG command decoder


;;; Reset entry into RUG command processor.

;;; (Falls through from previous page!)
rugcmd:	print ^"
*"				; prompt for reset
	mov o.bw,oo.bw		; save byte/word open flag and
	clr o.bw		; close all
	mov pwmode,twmode	; reset temporary modes
	mov pbmode,tbmode	; ...
	mov pabsmd,tabsmd	; ...
	mov pradix,tradix	; ...
	br rcd2


;;; NXM trap vector points directly to NXMERR to catch NXMs while RUG is
;;; running (TRAP4 is a default routine for program NXM traps).

nxmerr:	mov #stack,sp		; reset stack pointer before trying to use
				; stack
	print ^"--NXM"		; tell user 
err:	print ^"?"		; feep at loser
	;; fall through to command processor


;;; Non-reset entries into RUG command processor.

rcd1:	print ^"   "
rcd2:	mov #stack,sp		;reset stack so errors can jump here
	call bufclr		;clear char buffer
	clr altcnt		;no alts yet
	clr argcnt
	call ininst		; try parsing input as an instruction first
	  br rcd3
	mov #buf,bufptr		; reread typein so far
	call exp		; interpret as an expression this time
	mov r2,cvflgs
	bit #%nilv,r2		; was expression null?
	if eq,<			; no
	  mov r4,cvalue		; set current value
rcd3:	  inc argcnt		; one more arg
	  >
rcd4:	call bufrdu		; get command character
	mov #comls1,r1		; ptr to list of command characters
	movb r0,ncom(r1)	; put char at end of list
loop <	  cmpb r0,(r1)+
	  rptl ne
	  >
	sub #comls1+1,r1	; get offset into list
	asl r1			; multiply by two
	call @comls2(r1)	; go to proper routine
	br rcd1

alt:	inc altcnt		;keep track of no of alts
	br rcd4

.sbttl	Command routines

; Process CR - close location.
cr:	call close		; close current location
	jbr rugcmd		; return to decoder

; Process LF - open next word.
lf:	call close		; close present cell if any
	tst o.bw		; anything open?
	if eq,<
	  mov oo.bw,o.bw	; no, reset to prev open mode
	  >
	bit #%regv,clflgs	; location a register?
	if eq,<
	  add length,clocat	; no, move down length of cvalue
	  >
	else <
	  inc clocat		; else only increment by one
	  >
lf1:	call crlf
	push clocat,clflgs	; SYM args: value, flags
	call sym		; typeout clocat
	cmp o.bw,#1		; word or byte mode?
	if ne,<
	  printc '/
	  >
	else <
	  printc '\
	  >
	jcall open		; open clocat

; Process ^ - open previous word.
up:	call close		;close open location
	tst o.bw		;anything open?
	if eq,<
	  mov oo.bw,o.bw	;no, reset to prev open modes of
	  >
	bit #%regv,clflgs	; register location?
	if eq,<
	  sub o.bw,clocat	; no, subtract 1 or 2 for byte or word mode
	  br lf1
	  >
	dec clocat		; register, subtract 1
	br lf1			;go do the rest

; Process TAB - open current value.
tab:	mov cvalue,clocat
	mov cvflgs,clflgs
	br lf1

; Process @ - Open location addressed by user PC as instr
openpc:	mov upc,clocat		; make PC current location
	clr clflgs		; clear current flags
	mov #tyinst,twmode	; force instruction mode
	br lf1


; Process [ - open as no.
onum:	mov #tycons,twmode
	br oword

; Process ] - open as symbol.
osym:	mov #tysymb,twmode
;	br oword

; Process / - open word.
oword:	mov #2,o.bw		; set word mode
obw:	mov cvalue,clocat	; set address to open
	mov cvflgs,clflgs	; set address flags
	jcall open

; Process \ - open byte.
obyte:	mov #1,o.bw		; set byte mode
	br obw

; Process = - type out value as constant.
equal:	push cvalue,cvflgs	; CONST args: value, flags
	call const		; type current value as constant
	return


; Process _ - retype q in symbolic mode.
; (Command dispatches directly to TYSYMB.)


; Process : - define label
; Note: this command not interpreted through the regular command symbol
; and jump tables, but by a special check at ininst
label:	call bufrd		; read the :
	mov clocat,cvalue
	mov clflgs,cvflgs
	br def

; Process > - define symbol
define:	call gsym		; read symbol name
;	jcall def

; DEF defines a symbol.
def:	call svalue		; find where symbol is in table
	pop r0,*		; just get flags
	mov sptr,r1		; ptr to symbol if defined
	bit #%ndef,r0		; defined?
	if ne,<
	  mov stend,r1		; ptr to bottom of symbol table
	  asl sbit		; move to next bit in flag words
	  if eq,<		; end of group, create new group
	    inc sbit		; put 1 in sbit
	    mov r1,sflgp	; save ptr to register flag word
	    cmp -(r1),-(r1)	; create two flag words
	    clr 4(r1)		; clear all register flag bits
	    mov #-1,2(r1)	; set all half killed bits
	    >
	  mov r1,stend		; save ptr to end
	  sub #6,stend		; move down one symbol slot
	  mov s1,-4(r1)		; set symbol name
	  mov s2,-2(r1)		; ...
	  >
	mov cvalue,(r1)		; set value of symbol
	mov sflgp,r4		; ptr to register flag word
	bit #%regv,cvflgs	; check register flag, value a register?
	if ne,<
	  bis sbit,(r4)		; yes, set symbol's bit in register flags
	  >
	else <
	  bic sbit,(r4)		; no, clear register-flag bit
	  >
	bit #%half,cvflgs	; check half killed flag
	if ne,<
	  bis sbit,-(r4)	; half killed, set symbol's bit in flag word
	  >
	else <
	  bic sbit,-(r4)	; clear half killed bit
	  >
	return


; Process FOOK and FOOK - Kill defined symbol.
kill:	cmp altcnt,#2		; half or full kill?
	blo 1$
	tst argcnt		; full kill, no arg?
	if eq,< 		; no arg, kill all symbols
	  mov #symtop,stend 	; move up end of symbol table ptr
	  return
	  >
	mov sptr,r4
	clr (r4)
	clr -(r4)
	clr -(r4)
1$:	mov sflgp,r4		;ptr to symbol's reg-flag word.
	bis sbit,-(r4)		;set half-kill bit in hkill word.
	return


;;; Process z, zero all of user core.
zero:	cmp altcnt,#2		;see if we are $$z or not
	if ne,<
	  jbr err
	  >
;	jcall zero1

zero1:	;; zero program address space
	;; it might be useful if we set UPS to PR7 here
.if eq asmrt1
.if ne asmmap
        ; restore user map to identity map
	mov #uipar,r0		; R0: address of user PARs
	clr r1			; R1: page addressses
loop <	  mov r1,(r0)+		; set up identity map
	  add #200,r1
	  cmp r0,#uipar+<2*6>
	  rptl los
	  >
	mov #177600,(r0)+	; last page is I/O page
.endc
	clr r1			; init starting at 0
	clr (r1)+		; init 0
	clr (r1)+		; init 2
	mov #nxmerr,(r1)+	; set nxm trap vector to RUG's running value
	mov #pr7,(r1)+		; ...
	mov #trap4,sv4		; not quite zero, start off with a user NXM
	mov #pr7,sv6		; trap handler that enters RUG
.iff
	mov #1000,r1		; leave rt-11 alone!
.endc
.if eq  asmmap
loop <	  clr (r1)+
	  cmp r1,stend		; to bottom of symtab
	  rptl los
	  >
	return
.iff
loop <	  clr (r1)+
	  cmp r1,#mapjmp
	  rptl lo
	  >
	mov #mapjen,r1
loop <	  clr (r1)+
	  cmp r1,#8192.
	  rptl lo
	  >
loop <	  push r1
	  call map
	  pop r2
	  mov #4096.,r3
	  mov #1$,@#4
  loop <    clr (r2)+
	    sorl r3
	    >
	  add #8192.,r1
	  cmp r1,#160000
	  rptl lo
	  >
	return
1$:	mov #nxmerr,@#4
	cmp (sp)+,(sp)+
	return
.endc

; Process the ":XXXXXX" commands -- NOT the label definition "LABEL:" which
; is not handled thru the command table.  Name of command is 6 letters, two
; rad50 words.  COLTAB is table of colon com routines.

colon:	call gsym		; get command name as 2 rad50 words in s1, s2
	mov #coltab-6,r5	; ptr to com table
loop <	  add #6,r5		; next command in table
	  tst (r5)		; end of table?
	  exitl eq		; yes, command not found
	  cmp (r5),s1		; match the command name?
	  rptl ne		; no
	  cmp 2(r5),s2
	  rptl ne		; no
	  jmp @4(r5)		; yes, to that routine
	  >
	jbr err			; command not found


; :HELP lists the available : commands.
colhlp:	mov #coltab,r5		;ptr into : command table.
loop <	  call crlf
	  mov (r5)+,s1		;no, 1st 3 letters.
	  exitl eq
	  mov (r5)+,s2		;last 3 letters.
	  call type50		;print rad50 : com name.
	  tst (r5)+		;past ptr to routine.
	  rptl
	  >
	jbr rugcmd

.if ne asmrt1
;;; :EXIT returns to RT-11.
exit:	call crlf
	call rstat		; restore program state first
	call ristat		; then initial RT11 state
	.exit
.endc

.sbttl Breakpointing commands

; B - Set breakpoint
setbpt:	bit #%nilv,cvflgs
	bne 1$			;for now that command is meaningless
	bit #1,cvalue
	bne 1$			;badness if odd address
	call delb		;delete any old breakpoint at this address
	mov #bptadr,r4
	mov #nbpt,r0
loop <	  cmp (r4)+,#-1		;is this cell free?
	  exitl eq		;jump if yes
	  sorl r0
1$:	  jbr err
	  >
	mov cvalue,-(r4)	;set breakpoint
	mov #1,bptcnt-bptadr(r4)
	return


; U - Delete breakpoint
delb:	clr r4
loop <	  bit #%nilv,cvflgs
	  if eq,<
	    cmp cvalue,bptadr(r4)
	    bne 1$
	    >
	  mov #-1,bptadr(r4)
	  mov #<bpt>,bptins(r4)	; reset contents of table
	  clr bptcnt(r4)	; clear count
1$:	  tst (r4)+
	  cmp r4,#nbpt*2
	  rptl lo		; done
	  >
	return



; The :LISTB command prints a list of the breakpoints set, in
; the same format used when breakpoint is hit.  In addition
; the proceed count is printed if it is not 1.

;E.g., "$3B;   FOO+4>>MOV  #4 , @#6"
; or,  "$3B;   FOO+4>>MOV  #4 , @#6    ( 3 )"

listb:	push clocat		; save current location
	mov #bptadr,r5		; ptr to breakpoint address array
	clr r0			; R0: breakpoint number
loop <	cmp (r5),#-1		; this slot free?
	if ne,<
	  push r0		; save reg
	  mov (r5),clocat	; address of this breakpoint
	  call lstbpt
	  mov bptcnt-bptadr(r5),r0	; proceed count
	  cmp r0,#1		; print count?
	  if ne,<
	    print ^"      ( "
	    call tnumbr		; print proceed count
	    print ^" )"
	    >
	  pop r0		; restore reg
	  >
	inc r0			; next breakpoint
	tst (r5)+
	cmp r0,#nbpt		; done? (8 breaks, 0 - 7)
	rptl lo
	>
	pop clocat		; restore current location
	call crlf
	jbr rugcmd

.sbttl Mode decoding

; Location typeout modes (word)

; I - Instruction typeout mode
imode:	mov #tyinst,r1
	br setwm

; C - Constant typeout mode
cmode:	mov #tycons,r1
	br setwm

; S - Symbol typeout mode
smode:	mov #tysymb,r1
	br setwm

; " - Ascii typeout mode
amode:	mov #tyasci,r1
	br setwm

; & - Rad50 typeout mode
rmode:	mov #tyrad5,r1
;	br setwm

setwm:	mov r1,semimd		; set semicolon mode
	mov r1,twmode		; set temporary mode
	cmp altcnt,#1
	if hi,<
	  mov r1,pwmode		; set permanent mode
	  >
	return


; Location typeout modes (byte)

; ` - Constant typeout mode
cmodeb:	mov #tybcon,r1
	br setbm

; ' - Ascii typeout mode
amodeb:	mov #tybasc,r1
;	br setbm

setbm:	mov r1,tbmode		; set temporary mode
	cmp altcnt,#1
	if hi,<
	  mov r1,pbmode		; set permanent mode
	  >
	return


; Address typeout modes

; A - absolute addr mode
absmd:	mov pc,tabsmd		; set temporary mode
absmd1:	cmp altcnt,#1
	if hi,<
	  mov tabsmd,pabsmd	; set permanent mode
	  >
	return

; $R - Relative addr mode
relmd:	clr tabsmd		; set temporary mode
	br absmd1


; O - Octal typeout mode
soct:	mov #8.,tradix		; set temporary output radix to 8
sradix:	cmp altcnt,#1
	if hi,<
	  mov tradix,pradix	; set permanent output radix to 8
	  >
	jbr rcd2

; D - Decimal typeout mode
sdec:	mov #10.,tradix		; set temporary output radix to 10
	br sradix


;semi-colon: retype $q in the most recently specified
;temporary or permanent mode.
semicn:	mov semimd,r1
	cmp altcnt,#1		; see if $; or $$;
	blo 2$
	beq 1$
	mov r1,pwmode		; set permanent mode
1$:	mov r1,twmode		; set temporary mode
2$:	jcall (r1)		; type out cvalue

.sbttl Location opening

open:	push r4			; save reg
	mov clocat,r4		; current location
	bit #%regv,clflgs	; current location a register?
	if ne,<
	  cmp r4,#nuregs-1	; check that its a valid register no.
	  if hi,<		; no,
	    .lif eq asmmap	; well, in a non mapping rug that's an error
	    jbr err		; (q: is it relly worth this check?)
	    .lif ne asmmap	; in a mapping rug its a reference to an
	    br 1$		;  internal Rug symbol
	    >
	  mov #2,o.bw		; force word mode
	  cmp twmode,#tyinst	; instruction mode?
	  if eq,<
	    mov #tysymb,twmode	; don't open registers in instruction mode
	    >
	  asl r4		; convert to address of saved value
	  add #uregs,r4		; ...
	  >
1$:
	mov r4,r0		; copy address
	bic #1,r0		; make word address
	mov #savls1,r1		; ptr to list of locations saved
loop <	  cmp r0,(r1)+		; this location on the list?
	  if eq,<
	    ror r4		; save low bit of r4
	    mov r1,r4		; yes, put its actual address in r4
	    adc r4		; restore low bit
	    exitl
	    >
	  tst (r1)+		; skip over save location
	  tst (r1)		; end of list?
	  rptl ne
	  >
	bit #1,r4		; odd address?
	if ne,<
	  mov #1,o.bw		; yes, force byte mode
	  >
	mov r4,caddr		; save address for close
	clr cvflgs		; init current value flags
	push r4			; GETW/GETB arg: location
	cmp o.bw,#1		; byte or word mode?
	if ne,<
	  mov twmode,r4		; R4: typeout subroutine for word mode
.if ne asmmap
	  bit #%regv,clflgs	; is this a register reference?
	  if ne,<		; yes, getw looked in the wrong address space
	    mov @0(sp),(sp)	; get a word from our own address space
	    br 2$		; else
	    >
.endc
	  call getw		; get the word
2$:	  mov #2,length		; default length is 2 bytes
	  >
	else <
	  mov tbmode,r4		; R4: typeout subroutine for byte mode
.if ne asmmap
	  bit #%regv,clflgs	; is this a register reference?
	  if ne,<		; yes, getb looked in the wrong address space
	    movb @0(sp),(sp)	; get a byte from our own address space
	    clrb 1(sp)
	    br 3$		; else
	    >
.endc
	  call getb		; get the byte
3$:	  mov #1,length		; all bytes are length 1
	  >
	pop cvalue		; GETW/GETB result: current value
	print ^"   "
	rts r4			; restore R4 and jcall @tbmode or @twmode

; OPENI open location as an instruction
openi:	push o.bw,twmode	; save modes
	mov #2,o.bw		; force to word and instr mode
	mov #tyinst,twmode
	call open
	pop twmode,o.bw
	return

; Close word or byte and exit, address in clocat.
; Upon entering, r2 has numeric flag, r4 has contents.
; If a byte or word is to be deposited into the open loc
; then PUTWRD or PUTBYT is called.  (They will check
; to see if the byte/word is to be put in core or on the
; core-image.)

close:	tst argcnt
	beq 1$
	cmp o.bw,#1		;closing byte, word, or none?
	blo 1$			;0, nothing to close
	if eq,<
	  push caddr,r4		;change, this is addr, contents
	  call putb		;put byte away
	  >
	else <
.if ne asmmap
	  bit #%regv,clflgs
	  if ne,<
	    mov cvalue,@caddr
	    return
	    >
.endc
	  mov .lenth,length	; .lenth is length of input value
	  push caddr,cvalue	;close instruction
	  call putw		;put val into @clocat
	  cmp length,#2
	  blos 1$		;return (no more to instr)
	  push caddr
	  add #2,(sp)		;next addr in instr
	  push cvalue+2		;next part to deposit
	  call putw		;deposit next part of value
	  cmp length,#4		;done this instr yet?
	  blos 1$		;yes, return.
	  push caddr		;no, one more time.
	  add #4,(sp)
	  push cvalue+4
	  call putw		;deposit last (3rd) part of
	  >
1$:	return

.sbttl	Typeout modes

; Location typeout (word)

; instruction typeout
tyinst:	mov cvalue,r0
	call inst
	  return		; ok return
;	br tycons		; did not find one, print as number

; constant typeout
tycons:	push cvalue,cvflgs	; CONST args: value, flags
	call const		; type current value as constant
	return

; symbol typeout
tysymb:	push cvalue,cvflgs	; SYMBOL args: value, flags
	call symbol		; type current value as symbol
	return

; ascii typeout
tyasci:	printc '"
	movb cvalue,r0		; current value low byte
	call typec		; type ascii char
	movb cvalue+1,r0	; current value high byte
	jcall typec		; type ascii char

; rad50 typeout
tyrad5:	printc '&
	mov cvalue,s1
	clr s2
	jcall type50


; Location typeout (byte)

; constant mode
tybcon:	mov cvalue,r0		; current value
	jcall tnumbr		; type as octal no.

; ascii mode
tybasc:	printc ''		; type '
	mov cvalue,r0		; current value
	jcall typec		; type as ascii character

.sbttl Search commands

; SEARCHES -	.M/   THE MASK
;		.M+2/ THE LOWER LIMIT
;		.M+4/ THE UPPER LIMIT

;;; arg$W - word search.
wsearc:	jsr r5,sinit
	;; come here to test each word.
	bic r4,(sp)
	cmp (sp)+,r3
	bne snext
	br stype


;;; arg$N - not-equal word search.
nsearc:	jsr r5,sinit
	;; come here to test each word.
	bic r4,(sp)
	cmp (sp)+,r3
	beq snext
	br stype
	

;;; arg$E effective address search.
esearc:	jsr r5,sinit
	;; come here to test each word.
	pop r0
	cmp r0,r3		; is (x) = k?
	beq stype
	mov r0,r1		; calc (x)+x+2
	add r2,r1		; ...
	add #2,r1		; ...
	cmp r1,r3		; is (x)+x+2 = k?
	beq stype
	movb r0,r0		; get low byte sign extended
	inc r0			; make offset from x+2
	asl r0			; ...
	add r2,r0
	cmp r0,r3		; is the result a proper relative branch?
	bne snext
	br stype


sinit:	tst (sp)+		; ignore saved R5
	tst argcnt		; check for object found
	beq 1$			; error if no object
	mov #2,o.bw		; set word mode
	mov smask+2,r2		; get origin
	mov cvalue,r3
	mov smask,r4		; get mask
	com r4			; complement so can BIC
	bic r4,r3		; protect a confused loser from total lossage
	br snext1
1$:	jbr err

stype:	mov r2,clocat
	call crlf
	push r2,#0		; SYM args: value, flags
	call sym		; type address
	print ^"/   "
	push r2			; GETW arg: location
	call getw		; get word
	pop cvalue
	push r3,r4
	call @twmode		; type contents
	pop r4,r3
	mov clocat,r2
	;; fall through to process next word

snext:	tstb @ttycsr
	bmi snext2
	add #2,r2
	cmp r2,smask+4
	bhi snext2
snext1:	push r2
	call getw
	jmp (r5)
snext2:	jbr rugcmd

.sbttl	Program loading

.if ne  asmrt1+asmsrl		; either RT11 or serial line loading

;;; Initialize variables so they don't need to be set when only one type of
;;; loading selected.
.if ne asmrt1
  %%tmp1===dgetlb
  %%tmp2===dgetlw
.iff
  %%tmp1===getlb
  %%tmp2===getlw
.endc

dgetba:	.word %%tmp1
dgetwa:	.word %%tmp2


.if ne asmrt1
				;get the rt11 macros
	.insrt chsncp;rt11m

defext:	.rad50 "BIN"
	.rad50 "BIN"
	.word 0,0
	.even
emtare:	.blkw 5			;for EMT traps to RT-11
rdpnt:	.word bufend		;init so we read a block
blkcnt:	.word 0			;block count is initially zero
bufbeg:	.blkw 256.
bufend=.
.endc


load:
  .if ne asmrt1*asmsrl
	print ^" L for serial line; R for RT11 " ; type a space after $L
	call bufrdu		; get menu selection
	call crlf
	cmpb r0,#'L		; serial line ?
	beq 1$
	cmpb r0,#'R		; RT11 file?
	beq 2$
	jbr rugcmd		;punt
  .endc

  .if ne asmrt1
2$:
	.settop #-2		;set top of core to address > than RMON
				;which will give us as much core as possible
;;; The following is completely random; GO is the $G command! -- EAK 7/23/81
	mov #go,@#46		;set up value for usr swapping
	print ^" Input RT-11 File Specifier:
"
	call ristat		; restore RT11's vectors and the like
	.csige #bufbeg,#defext,#0	; take input from terminal
	call sstat1		; set RUG vectors again (e.g. NXM trap
				; vector)
    .if ne asmsrl
	mov #dgetlb,dgetba	; set up for reading from RT-11 file
	mov #dgetlw,dgetwa
    .endc
	mov #bufend,rdpnt	;initialize for first transfer
	clr blkcnt		;clear the block count
	br 10$			;start loading program
  .endc
  .if ne asmsrl			; Handle serial line?
1$:	print ^" Serial line CSR addr ("
	mov srlcsr,r0		; choose default CSR addr.  Previous choice
	call tnumbr		; show default CSR address.
	print ^"): "
	call bufclr		; backup to here on rubout
	call rnumbr		; read no., return no.,flags on stack
	pop r0			; get possible CSR address
	bit #%nilv,(sp)+	; did we read a number?
	if eq,<
	  mov r0,srlcsr
	  >
	cmp srlcsr,#160000	; see if it is a reasonable addr
	if lo,<
	  print ^" Bad CSR addr"	; complain
	  jbr rugcmd		; punt
	  >
	print ^"
^G aborts"
    .if ne asmRT1
	mov #getlb,dgetba	; set up for reading from DLV typ device
	mov #getlw,dgetwa
    .endc
  .endc

10$:	cmp altcnt,#1		; $$L?
	if los,<
	  bis #%nilv,cvflgs	; simulate an $U with no arg
	  call delb		; ie. clear all breakpoints
	  mov #symtop,stend	; $L, clear core, flush symbols
	  call zero1
	  >
.lif ne  asmmap			; for now this will do
	mov #winvpg*200,@#winpar	; set window for identity map below
					; RUG
	clr errcnt
loop <	  call @dgetba		; look for header
4$:	  cmp r0,#1		; is it 1?
	  rptl ne
	  mov r0,r2		; initialize checksum
	  call @dgetba		; next should be zero
	  tst r0
	  bne 4$
	  call @dgetwa		; get byte count
	  mov r0,r5		; r5 will have the byte count
	  call @dgetwa		; get address
	  mov r0,r1
	  sub #6,r5		; correct byte count for stuff already read
	  exitl eq		; no data means end, and address is start
				; address
  loop <    call @dgetba	; get data byte
	    ;; check address against saved addresses.
	    mov #savls3,r3	; R3: list of saved addreses
    loop <    cmp (r3)+,r1	; match a saved address?
	      if eq,<		; yes
	        mov (r3),r4	; address of place where saved
		movb r0,(r4)+	; store into saved copy
		dec r5		; grab another byte
		beq 6$		; but be prepared to punt this block if it
		call @dgetba	;  end on an odd byte
		movb r0,(r4)	; store high byte of saved copy
		tst (r1)+	; advance r1
		br 3$
		>
	      tst (r3)+
	      tst (r3)
	      rptl ne
	      >
.if eq asmmap
	    ;; insure that address isn't in RUG
	    cmp r1,stend	; below RUG?
	    blo 5$		; yes, ok
	    cmp r1,#lastlc	; above RUG?
	    bhi 5$		; no, ignore it
	    inc errcnt
	    br 3$
5$:	    movb r0,(r1)+	; store
.iff
	    push r1,r0
	    call putb
	    inc r1
.endc	; asmmap
3$:	    sorl r5
	    >
6$:	  ;; end of block.  read checksum.
	  call @dgetba		; get checksum
	  tstb r2		; checksum zero?
	  rptl eq		; yes, ok
	  inc errcnt		; no, increment error count
	  rptl
	  >
	;; zero length block: end of data, start address.
	mov r1,starta
	call @dgetba		; get checksum
	tstb r2			; checksum zero?
	if ne,<
	  inc errcnt
	  >

	;; now load symbols

	;; find last symbol in symbol table and current flag words and mask
	mov stbeg,r1		; ptr to one before start of symbol table
	clr r3			; bit flag
loop <	  sub #6,r1		; move ptr to next symbol
	  cmp r1,stend		; check for end of symbol table
	  exitl los
	  asl r3		; next bit
	  rptl ne
	  ;; 16 symbols: get new flag word
	  inc r3		; set bit 1 for first symbol
	  mov r1,r4		; save ptr to register flag words
	  cmp -(r1),-(r1)	; move symbol ptr past flag words
	  rptl
	  >
	; upon exiting this loop,
	; R4 -> flag words, -2(r4) is half killed flags, (r4) reg flags
	; R1 -> first unused symbol word
	; R3 -> mask for flag bits of current symbol

	call @dgetba		; check for symbols
	cmpb r0,#2		; symbols?
	bne lend		; no
loop <    call @dgetwa		; get 1st three chars of name
	  push r0		; save them
	  beq lend		; zero word terminates
	  call @dgetwa		; get 2nd three chars of name
	  push r0		; save them
	  call @dgetwa		; get flags
	  mov r0,r5		; stick flags in R5 for easy access
	  call @dgetwa		; get value
	  bit #10000,r5		; is this an undefined symbol?
	  if ne,<		; yes,
	    cmp (sp)+,(sp)+	; clear cruft off stack
	    rptl		; and try for next symbol
	    >
	  asl r3		; next bit
	  if eq,<		; if 16 symbols then get new flag word
	    inc r3		; set bit 1 for first symbol
	    mov r1,r4		; save ptr to register flag word
	    cmp -(r1),-(r1)	; move symbol ptr past flag words
	    clr (r4)		; clear register bits
	    mov #-1,-2(r4)	; but initially set half kill bits
	    >
	  mov r0,(r1)		; save value
	  mov (sp)+,-2(r1)	; save first word of RAD50 name
	  mov (sp)+,-4(r1)	; 2nd word
	  bit #20000,r5		; half killed?
	  if ne,<
	    bis r3,-2(r4)
	    >
	  else <
	    bic r3,-2(r4)
	    >
	  bit #4000,r5		; register?
	  if ne,<
	    bis r3,(r4)
	    >
	  else <
	    bic r3,(r4)
	    >
	  sub #6,r1		; move to next symbol
	  mov r1,stend
	  rptl
	  >

labort:	print ^" LOADING ABORTED"
lend:	print ^" Error count= "
	mov errcnt,r0
	call tnumbr
	jbr rugcmd


; GETLB reads a byte from the serial line.  Adds it into checksum
; stored in R2.  Returns byte read in R0
getlb:	push r1,r3
	mov srlcsr,r1
	mov ttycsr,r3
2$:	cmp r1,r3
	beq 1$
	tstb (r3)
	if mi,<
	  cmpb 2(r3),#7		; ^G aborts
	  beq labort
	  >
1$:	tstb (r1)
	bpl 2$
	clr r0
	bisb 2(r1),r0
	add r0,r2		; add it into checksum
	pop r3,r1
	return

; GETLW reads two bytes and assembles them into a word in R0
getlw:	call getlb		; get first byte, low order
	push r0			; save it
	call getlb		; get high order byte, note that the high
	swab r0			; byte is always guaranteed to be zero
	add (sp)+,r0		; combine the two bytes into a word, note
	return			; no overlapping bits, no chance of carry
.endc

.if ne asmrt1
; DGETLB reads a byte, adds to the checksum in R2 and returns the byte
; in R0
dgetlb:	cmp rdpnt,#bufend	;at end of buffer yet?
	if his,<			;get byte
	  .readw #emtare,#3,#bufbeg,#256.,blkcnt	;get data
	  if cs,<		;no error
	    tstb @#52		;did we read past the end of the file?
	    if eq,<		;no.
	      clr bufbeg	;end of symbol table is a zero word
	      clr bufbeg+2	;ditto
	      >
	    else <
	      print ^"I/O Error"
	      jmp labort	;abort the loading
	      >
	    >
	  inc blkcnt		;up the block count
	  mov #bufbeg,rdpnt	;reset the read pointer
	  >
	clr r0
	bisb @rdpnt,r0		;get the byte
	inc rdpnt		;inc the pointer
	add r0,r2		;add to checksum
	return			;done

; DGETLW reads two bytes and assembles them into a word in R0
dgetlw:	call dgetlb		; get first byte, low order
	push r0			; save it
	call dgetlb		; get high order byte, note that the high
	swab r0			; byte is always guaranteed to be zero
	add (sp)+,r0		; combine the two bytes into a word, note
	return			; no overlapping bits, no chance of carry
.endc

.sbttl Program Dumping

.if ne <asmrt1+asmsrl>*asmdmp
dputwa:	.word			; address of routine to put out a word
dputba:	.word			; ditto for a byte
dclose:	.word			;close file routine
dump:
.if ne asmrt1*asmsrl
	print ^" L for serila line R for RT-11 "	;which to dump onto?
	call bufrdu		;get a menu selection
	call crlf
	cmpb r0,#'L		;serial line?
	beq 1$			;do serial line

	cmpb r0,#'R		;do RT-11 file
	beq 2$
	jbr rugcmd		;huh?
.endc

.if ne asmrt1
2$:

	print ^" Input RT-11 File Specification: (foo.bin=)
"
	call ristat		;restore the state of the world
	.csige #bufbeg,#defext,#0	;take input from terminal
	call sstat1		;set NXM trap vector
	mov #dputlb,dputba	;setup for writing to RT-11 file
	mov #dputlw,dputwa
	mov #rt11cl,dclose
	mov #bufbeg,rdpnt	;initialize to fill first buffer
	clr blkcnt		;clear the block count
	br actdmp		;continue dumping
.endc

.if ne asmsrl
1$:
	print ^" Input CSR addr of serial line ("
	mov srlcsr,r0		;choose default CSR
	if eq,<
	  mov ttycsr,r0		;he has made no previous choice- use console
	  >
	mov r0,srlcsr		;setup default
	call tnumbr		;type out the number
	print ^"): "
	call bufclr		;we backup to here on rubout
	call rnumbr		;read a number from the user
	pop r0			;get the number read
	bit #%nilv,(sp)+	;was it a number we got?
	if eq,<
	  mov r0,srlcsr
	  >
	print ^"
^G aborts"
	mov #putlb,dputba	;set up for reading from DLV type device
	mov #putlw,dputwa
	mov #srlcls,dclose	;close routine for a serial line
	cmp srlcsr,#160000	;is this a reasonable number?
	bhis actdmp
	print ^" Bad CSR addr "	;complain to user
	jbr rugcmd
.endc

actdmp:	mov dmplow,r3		;low address for dumping
	mov dmphi,r4		;high address for dumping

loop <  mov r4,r1		;save high addr
	sub r3,r1		;size in r1

	if gt,<
  loop<   tstb (r3)+		;see if the byte is zero
	  bne 2$		;get one not zero?
	  sorl r1
	  >>
	  br 4$

2$:	dec r3			;back up
4$:	clr r2			;clear out the checksum
	cmp r3,r4		;anything to dump?
	if lo,<
	  mov r3,r1		;save pointer

1$:
	  .rept 5		;look for five of more zero bytes in a row
	   cmp r1,r4		;at the end yet?
	   if lo,<
	     tstb (r1)+
	     bne 1$
	     >
	  .endr
	  sub r3,r1		;get size of block
	  call strtbl		;output block header
	  mov r1,r0		;put out size of block
	  add #6,r0		;account for the block header
	  call @dputwa
	  mov r3,r0		;put out address of block
	  call @dputwa

   loop <   movb (r3)+,r0	;get byte to output
	    call @dputba
	    sorl r1
	    >

	  neg r2		;convert to proper checksum
	  mov r2,r0		;output checksum
	  call @dputba
	  >
	cmp r3,r4
	rptl lo
	>

	clr r2			;init checksum
	call strtbl		;output the block header
	mov #6,r0		;block length of six
	call @dputwa
	mov starta,r0		;put out start address
	call @dputwa
	neg r2			;correct checksum
	mov r2,r0
	call @dputba

; Now dump symbols

	mov #2,r0		; output a flag for symbols
	call @dputba
	mov #symtop+6,r1	; ptr to before 1st symbol's value word
	clr r3
loop <	  sub #6,r1		; move ptr to next symbol
	  cmp r1,stend		; beyond end of symbol table?
	  exitl los
	  asl r3		; get its bit in flag words
	  if eq,<		; move to next group of 16 symbols
	    inc r3		; set bit 1 for first symbol
	    mov r1,r4		; save ptr to register flag word
	    cmp -(r1),-(r1)	; move ptr over flag words to value cell
				; of first symbol
	    >
	  tst -4(r1)		; anything there?
	  rptl eq
	  mov -4(r1),r0	
	  call @dputwa		; write out 1st three chars of name
	  mov -2(r1),r0
	  call @dputwa		; write out 2nd three chars of name
	  clr r0		; flag word
	  bit r3,(r4)		; register value?
	  if ne,<
	    bis #4000,r0	; yes, set register flag in flag word
	    >
	  bit r3,-2(r4)		; half killed?
	  if ne,<
	    bis #20000,r0
	    >
	  call @dputwa
	  mov (r1),r0
	  call @dputwa		; write out symbol value
	  rptl
	  >
	clr r0			; DPUTW arg: word
	call @dputwa		; write zero word to terminate symbols
	call @dclose		;close the file
	jbr rugcmd

strtbl:	mov #1,r0		;write out start block
	call @dputba
	clr r0
	jcall @dputba

dabort:	print ^" DUMPING ABORTED"
	jbr rugcmd

.if ne asmsrl
; PUTLB writes a byte to a DLV type serial line
putlb:	push r1,r3
	mov srlcsr,r1		;get the csr in r1
	mov ttycsr,r3		;get the console CSR in r3
1$:	tstb (r3)		;is there a char?
	if mi,<
	  cmpb 2(r3),#7		;^G aborts
	  if eq,<
	    pop r3,r1		;pop off registers
	    call dclose		;close the file?
	    br dabort		;dumping aborted
	    >
	  >
	tstb 4(r1)		;can we send a char yet?
	bpl 1$			;wait for char to arrive
	movb r0,6(r1)		;get char
	push r0			;save onto the stack;
	bic #177400,(sp)	;mask to 8 bits
	add (sp)+,r2		;accumulate checksum
	pop r3,r1
	return

; PUTLW writes out a word to the DLV type serial line
putlw:	call putlb		;output the low byte
	swab r0			;swap the bytes
	jcall putlb		;send the high byte

; SRLCLS closes the serial line by writing a zero byte
srlcls: clr r0			;output a zero byte to end the file
	jcall putlw
.endc

.if ne asmrt1
; DPUTLB write a byte to an RT-11 file open on channel 0.
dputlb:	cmp rdpnt,#bufend	;at end of buffer yet?
	if his,<		;put byte
	  .writw #emtare,#0,#bufbeg,#256.,blkcnt	;put out data
	  bcs wlos		;handle error
	  inc blkcnt		;up the block count
	  mov #bufbeg,rdpnt	;reset the pointer
	  >
	movb r0,@rdpnt		;get the byte
	inc rdpnt		;bump the pointer
	push r0			;save onto stack
	bic #177400,(sp)	;clear out high byte
	add (sp)+,r2		;add to checksum
	return			;done

;DOUTLW writes a word as two bytes to the file open on channel 0
dputlw: call dputlb		;put out the low byte
	swab r0			;swap the bytes
	call dputlb		;put out the high byte
	return			;done

;RT11CL closes the RT-11 file open on channel 0.
rt11cl:	cmp rdpnt,#bufbeg	;if the buffer is not empty then write it.
	if ne,<
	  .writw #emtare,#0,#bufbeg,#256.,blkcnt	;put out data
	  if cs,<		;Tell user about I/O error
wlos:	    print ^"I/O Error"
	    .close #0		;close the file for good measure
	    br dabort		;abort the dumping
	    >
	  >
	.close #0
	return			;done
.endc
.endc

.sbttl Breakpoint

.iif eq  asmmap, bpth:
bpthx:	tst ssflag		; tracing?
	if ne,<
.if eq pdp11-23
	  cmp (sp),upc		; was PC unincremented?
	  beq 1$		; yes, proceed for another instr
.endc
	  dec count		; count reached?
	  if ne,<		; no
1$:
.if eq asmmap
	    bis #20,2(sp)	; make sure trace bit still on
	    rtt			; keep going
.iff
	    push #2		; compute 2(user sp)
	    add sp,(sp)
	    call map		; map it in
	    bis #20,@(sp)+	; set trace bit in user PS
	    jmp @#contx
.endc
	    >
	  >
.if eq  asmmap
	pop upc,ups		; save pc and ps
	mov sp,usp		; save stack ptr
	mov #stack,sp		; setup RUG's stack
.iff
	mov sp,usp
	mov #stack,sp		; setup RUG's stack
	push usp
	call getw
	pop upc
	add #2,usp
	push usp
	call getw
	pop ups
	add #2,usp
.endc	
	call sstat		; save rest of machine state
	tst proflg		; trace trap from proceed?
	if ne,<
	  bic #20,ups		; clear trace bit
	  clr proflg		; clear flag
	  call setbrk		; set breakpoints
	  jmp contin		; continue program
	  >
	mov upc,clocat		; set current location to after instruction
	clr clflgs		; ...
	tst ssflag		; single stepping?
	if ne,<
	  bic #20,ups		; clear T bit in user ps
	  call crlf
	  br bph2
	  >
	call rembrk		; remove breakpoints
	sub #2,upc		; correct for incrementation of pc
	sub #2,clocat		; ...
	mov #nbpt*2-2,r4	; get a counter
loop <	  cmp clocat,bptadr(r4)	; compare with list
	  exitl eq		; jump if found
	  sub #2,r4
	  rptl ge		; re-loop until found
	  print ^"
BE; "
bph1:	  mov #-1,bptno		; not stopped by breakpoint, set bpt no to -1
bph2:	  call lstbp1
	  jbr rcd1
	  >
	dec bptcnt(r4)		; finished count?
	bne proc1		; no, continue
	mov #1,bptcnt(r4)	; set proceed count to 1
	mov r4,r0		; get n*2
	asr r0			; divide by two
	mov r0,bptno		; save bpt no.
	call lstbpt
	jbr rcd1

.if eq  asmmap
trap4:	pop upc,ups		; save user PC and PS
	mov sp,usp		; save user SP
	mov #stack,sp		; setup RUG's stack
.iff
trap4x:	mov sp,usp
	mov #stack,sp		; setup RUG's stack
	push usp
	call getw
	pop upc
	add #2,usp
	push usp
	call getw
	pop ups
	add #2,usp
.endc	
	call sstat		; save processor status
	call rembrk		; remove breakpoints if they're set
	mov upc,clocat		; set current location to be that of trap
	print ^"
NXM; "
	br bph1


lstbpt:	print ^"
$"
	call tnumbr		; print bpt no.
	print ^"B; "
lstbp1:	push clocat,#0		; SYMBOL args: value, flags
	call symbol		; print symbolic address <<
	print ^">>"		; indicate RUG opened it
	jcall openi		; open as an instruction

.sbttl Go and Proceed commands

; $G - Go
go:	mov cvalue,r5		;get starting address
	tst argcnt		;arg specified?
	if eq,<
	  mov starta,r5		;no, set start address from default
	  >
	bit #1,r5		;check low order bit
	bne 2$			;error if odd number
	cmp altcnt,#2		;set the default?
	if eq,<
	  mov r5,starta		;yes, set it to arg
	  >
	mov r5,upc		;set up new pc
	cmp usp,stend		; make sure stack ptr is within bounds
	bhi 1$
	cmp usp,#402
	if los,<
1$:	  mov #1000,usp		; not in bounds, reset it
	  >
	call setbrk		;set breakpoints
	clr ssflag		;not single stepping
	bic #20,ups		;make sure trap bit off
	br contin		;start program
2$:	jbr err


; $P - Proceed from a breakpoint 
proced:	mov cvalue,r5
	tst argcnt		; was count specified?
	if eq,<
	  mov #1,r5		; no count, use 1
	  >
	mov bptno,r0
	if pl,<
	  asl r0		; times two for word operations
	  mov r5,bptcnt(r0)	; set proceed count
	  >
; come here from BPTH if count nonzero
proc1:	clr ssflag
	bis #20,ups		; set trace trap bit
	mov pc,proflg		; now step over next instruction
	br contin		; and then restore BPTs and continue

; ^N - Single step
sstep:	mov cvalue,count
	tst argcnt		; arg specified?
	if eq,<
	  mov #1,count		; no arg, assume a single step
	  >
	mov pc,ssflag		; set single step flag
	bis #20,ups		; set trace trap bit in PS
	; fall through to CONTIN


contin:	call rstat		; restore registers etc.
	mov #bpth,@#14		; set breakpoint trap vector
	mov #pr7,@#16		; high priority
.if eq  asmmap
	mov usp,sp		; restore user stack ptr
	push ups,upc		; setup ps,pc for rti
	rtt
.iff
	sub #2,usp
	push usp,ups
	call putw
	sub #2,usp
	push usp,upc
	call putw
	mov usp,sp
	jmp @#contx
.endc

;;; set breakpoints 0-7

setbrk:	com bptset		; test if breakpoints already set
	beq rughlt		; yes, RUG error
	mov #nbpt*2-2,r1	; restore all breakpoints
loop <	  cmp bptadr(r1),#-1
	  if ne,<
	    push bptadr(r1)
	    call getw		;save contents
	    pop bptins(r1)
	    push bptadr(r1),#<bpt>
	    call putw		;replace with trap
	    >
	  sub #2,r1
	  rptl pl		;re-loop until done
	  >
	return


; remove breakpoints 0-7
;   in the opposite order of setting

rembrk:	com bptset		; test if breakpoints set
	bne rughlt		; no, RUG error
	clr r1
loop <	  cmp bptadr(r1),#-1
	  if ne,<
	    push bptadr(r1),bptins(r1)
	    call putw		; clear breakpoint
	    >
	  tst (r1)+
	  cmp r1,#nbpt*2
	  rptl lo
	  >
	return

rughlt:	halt

.sbttl	save/restore processor state

; save processor state
sstat:
.if ne asmmap
	mov mapjr0,uregs+0
	mov mapjr1,uregs+2
	mov #uregs+4,r0
.iff
	mov r0,uregs+0		; save r0
	mov #uregs+2,r0		; address of register save area
	mov r1,(r0)+
.endc
	mov r2,(r0)+
	mov r3,(r0)+
	mov r4,(r0)+
	mov r5,(r0)+
	mov #savls2,r1		; get list of locations to save
loop <	  mov @(r1)+,(r1)+	; save location in its save place
	  tst (r1)		; end of list?
	  rptl ne
	  >
sstat1:	mov @ttycsr,svrcsr	; save tty receiver csr
	bic #100,@ttycsr	; turn off interrupts so that user's typing
				; in RUG doesn't set DL11 interrupt pending
				; latch thus causing program (or RT11) to
				; reread the last character typed when we
				; continue/exit
	mov #nxmerr,@#4		; setup bus error trap
	mov #pr7,@#6
	return

; restore processor state
rstat:	mov #savls2,r1		; ptr to list of locations saved
loop <	  mov 2(r1),@(r1)+	; restore location's value
	  tst (r1)+		; skip over save location address
	  tst (r1)		; end of list?
	  rptl ne
	  >
	mov ttycsr,r1
loop <	  tstb 4(r1)		; wait for char to type
	  rptl pl
	  >
	mov svrcsr,(r1)		; then restore device status registers
	mov #uregs+14,r0	; ptr to register save area
	mov -(r0),r5		; restore r0-r5
	mov -(r0),r4
	mov -(r0),r3
	mov -(r0),r2
.if eq asmmap
	mov -(r0),r1
	mov -(r0),r0
.iff
	mov -(r0),mapcr1
	mov -(r0),mapcr0
.endc
	return

.if ne asmrt1	
sistat:	mov #savls4,r1		; list of locations to save
loop <	  mov @(r1)+,(r1)+	; save
	  tst (r1)		; end of list?
	  rptl ne
	  >
	return

ristat:	mov #savls4+2,r1
loop <	  mov (r1)+,@-4(r1)	; restore
	  tst (r1)+		; done?
	  rptl ne
	  >
	return
.endc

.sbttl	Instruction typeout - lookup

;;; R0/ 1st word of instruction.

inst:	mov #insts,r1		; start of instruction symbol table
loop <	  clr s2
	  tstb 1(r1)		; is it a flag?
	  if eq,<
	    tst (r1)+		; 2 word rad50 or change flag?
	    beq 1$		; if eq then 2 word rad50
	    mov (r1)+,r3	; R3: mask
	    mov (r1)+,r4	; R4: typeout routine
	    rptl
1$:	    mov (r1)+,s2
	    >
	  mov r0,r2		; to save value
	  bic r3,r2		; apply mask
	  cmp 2(r1),r2
	  if eq,<
	    mov (r1),s1
	    call type50
	    com r3
	    bic r3,r0
	    if mi,<
	      printc 'B
	      >
	    printc 40
	    jmp (r4)
	    >
	  cmp (r1)+,(r1)+
	  cmp r1,#inste		; done?
	  rptl los
	  >
	add #2,(sp)		; return2
	return

.sbttl	Instruction typein - lookup

ininst:	call gsym		; read instruction name
	tst s1			; anything there?
	beq 3$
	call bufpek		; special check to see if this is "label:"
	cmp r0,#':
	if eq,<
	  mov #rcd1,(sp)	; clobber return address to be command loop
	  jmp label
	  >
	mov #insts,r1		; start of instruction symbol table
loop <	  clr r4		; R4: 0 or 100000 if byte instruction
	  clr r5		; R5: 2nd rad50 word of instruction
	  tstb 1(r1)		; start of new instruction group or 2 word
				; rad50?
	  if eq,<		; yes
	    tst (r1)+		; 2 word rad50?
	    beq 1$		; yes
	    mov (r1)+,r2	; R2: mask word
	    mov (r1)+,r3	; get address of typeout routine
	    add -6(r1),r3	; add offset to get typein routine
	    rptl
1$:	    mov (r1)+,r5
	    >
	  cmp (r1)+,s1
	  bne 2$
	  cmp r5,s2
	  exitl eq
	  tst r5
	  bne 2$
	  mov #100000,r4
	  cmp s2,#6200		; 6200 = .rad50 /b  /
	  exitl eq
2$:	  tst (r1)+		; skip instruction value
	  cmp r1,#inste		; done?
	  rptl los
3$:	  add #2,(sp)
	  return
	  >
	add (r1),r4		; get value of instruction
	mov r4,val
	mov #2,.lenth
	tst r2			; mask non0? i.e. does instruction has some
				; sort of operands?
	if ne,<			; yes
	  call spchk		; insist on space following opcode name
	  >
	jmp (r3)		; goto proper typein routine

.sbttl	Instruction typein/typeout routines


;;; Double operand instruction typeout.
arith:	push r0			; save opcode
	ash #-6,r0		; SSORDD arg: operand
	call ssordd		; type source
dest2:	pop r0			; restore opcode
dest1:	printc 54		; comma
	;; fall through to single operand case

;;; Single operand instruction typeout.
singop:	call ssordd		; type destination

;;; No-operand instruction typeout.
.cntrl:	print ^"   "
	return

;;; RTS typeout.
.rts:	call dstreg		; type register
	jbr .cntrl

;;; JSR/XOR typeout
.jsr:	push r0			; save opcode
	call srcreg		; type register operand
	jbr dest2		; restore opcode, type comma and destination etc.



;;; Double operand instruction typein.
inop2:	call inssdd
	pop r4
jsr1:	ash #6,r4
	bis r4,val
	call comchk
	;; fall through to single operand typein.

;;; Single operand instruction typein.
inop1:	call inssdd
	bis (sp)+,val
	;; fall through to no operand typein.

;;; No operand instruction typein.
incntr:	mov val,cvalue
	mov val+2,cvalue+2
	mov val+4,cvalue+4
	mov .lenth,length
	return

;;; RTS typein.
inrts:	call getreg
inbyte:	bisb r4,val
	jbr incntr


;;; JSR/XOR typein.
injsr:	call getreg
	br jsr1

.if ne  eis
;;; EIS instruction typeout.
.eis:	push r0			; save opcode
	call ssordd		; type full operand as source
	printc 54		; comma
	pop r0			; restore opcode
	call srcreg		; type register operand as destination
	jbr .cntrl

;;; EIS typein.
ineis:	call inssdd
	bis (sp)+,val
	call comchk
	call getreg
	ash #6,r4
	bis r4,val
	jbr incntr
.endc	; ne eis

;;; Branch typeout.
.brchs:	movb r0,r0		; sign extend displacement
	inc r0
	asl r0
	add clocat,r0
	push r0,#0		; SYMBOL args: value, flags
	call symbol
	jbr .cntrl

;;; Branch typein.
inbrch:	call exp
	sub clocat,r4
	asr r4
	dec r4
inbyt1:	movb r4,r5
	cmp r4,r5
	beq inbyte
	jbr err


;;; SOB typeout.
.sob:	push r0
	call srcreg
	printc 54		; comma
	bic #177700,(sp)
	dec (sp)
	neg (sp)
	asl (sp)
	add clocat,(sp)
	push #0
	call symbol
	jbr .cntrl

;;; SOB typein.
insob:	call getreg
	ash #6,r4
	bis r4,val
	call comchk
	call exp
	sub clocat,r4		; subtract instr address from branch dest
	asr r4			; halve for word offset
	bcs 1$			; reject odd addresses
	dec r4			; correct for usual branch offset
	neg r4			; and branchs are always backwards
	cmp r4,#77
	blos inbyte		; make sure range is 0-77
1$:	jbr err


;;; TRAP/EMT typeout.
.trap:	jcall tnumbr

;;; TRAP/EMT typein.
intrap:	call exp
	br inbyt1


;;; Condition code instruction typeout.
cndcod:	clr s1			; flush instr once we've typed it out
	mov r0,r2
	ror r2
	if cs,<
	  add #3,s1		;.rad50 /  c/
	  >
	ror r2
	if cs,<
	  add #104600,s2	;.rad50 /v  /
	  >
	ror r2
	if cs,<
	  add #2020,s2		;.rad50 / z /
	  >
	ror r2
	if cs,<
	  add #16,s2		;.rad50 /  n/
	  >
	call type50
	jbr .cntrl

;;; Condition code instruction typein.
inccdd:
1$:	call bufrdu		; read an upper case char
	mov #1,r2
	mov #tbl,r3
loop <	  cmpb r0,(r3)+
	  if eq,<
	    bis r2,val
	    asl r2
	    br 1$
	    >
	  asl r2
	  tstb (r3)		;signals end of table
	  rptl ne
	  >
	call bufrrd		; if it wasn't a condition code, put it back
	jbr incntr

tbl:	.byte 'C
	.byte 'V
	.byte 'Z
	.byte 'N

;;; Subroutines for instruction input.

comchk:	call bufrd
	cmp r0,#',
bneerr:	bne %err
	return

spchk:	call bufrd
	cmp r0,#40
	br bneerr

getreg:	call exp
	cmp r4,#7
	bhi %err
	bit #%nilv,r2
	br bneerr

.sbttl	Instruction typeout - addresses

; SSORDD - types out a source or destination field of an instruction.
;	ARGS:				VALS:
; R0 -> address syllable in	  R0 -> effective address of source or dest
;	 low 6 bits		  R1 -> flag word for R0 (ie.  %regv or not)
; CLOCAT -> 1st word of instr	  R2 -> non-zero if deferred
ssordd:	mov r0,r1		; R1: address mode
	ash #-3,r1		; ...
	bic #177770,r1		; ...
	bic #177770,r0		; R0: register
	clr r2			; use as flag to say whether deferred
	bit #1,r1		; deferred mode?
	if ne,<
	  mov pc,r2		; flag
	  bic #1,r1		; clear bit, check if register deferred mode
	  beq 1$		; register deferred mode, type (R)
	  printc '@		; not register deferred, preceed with @
	  >
	add r1,pc		; decode mode
	br regtyp		; register
	br 2$			; autoincrement
	br 3$			; autodecrement

	;; X(R)
	call tinget		; get next word of instruction
	cmp r0,#7		; PC?
	if eq,<
	  add clocat,(sp)	; make offset into absolute address
	  add length,(sp)	; ...
	  push #0		; SYM arg2: flags
	  call sym		; type A
	  return
	  >
	push #0			; SYM arg2: flags
	call sym		; arg1 on stack from TINGET
1$:	printc '(		; type x(R)
	call regtyp	
	printc ')
	return

2$:	;; (R)+
	cmp r0,#7		; PC?
	if eq,<
	  printc '#		; type #N
	  call tinget		; get next word of instruction
	  push #0		; SYM arg2: flags
	  call sym		; arg1 on stack from TINGET
	  return
	  >
	call 1$			; type (R)
	printc '+		; type +
	return

3$:	;; -(R)
	printc '-		; type -
	br 1$			; type (R)

srcreg:	ash #-6,r0
dstreg:	bic #177770,r0
	;; fall through to REGTYP

regtyp:	push r0,#%regv		; SYM args: value, flags
	call sym
	return

tinget:	push (sp)		; slot for result
	mov clocat,2(sp)	; current location
	add length,2(sp)	; skip over first part of instruction
	add #2,length		; instruction now another word long
	jcall getw		; get next word

.sbttl	Instruction typein - addresses

inssdd:	push (sp)		; make slot for return val
	clr 2(sp)		; initially zero
	call bufrd		; get next character
	cmp r0,#'@
	if eq,<
	  bis #10,2(sp)		; @, turn on indirect bit in address
	  call bufrd		; get another character
	  >
	cmp r0,#'#
	if eq,<
	  call exp
	  bit #%regv+%nilv,r2
	  bne 3$
	  bis #27,2(sp)
	  br appval
	  >
	cmp r0,#'-
	if eq,<
	  call bufrd
	  cmp r0,#'(
	  beq 1$
	  call bufrrd
	  >
	cmp r0,#'(
	beq 2$
	call bufrrd
	call exp
	bit #%nilv,r2
	bne 3$
	bit #%regv,r2
	if ne,<
	  cmp r4,#7
	  bhi 3$
	  bis r4,2(sp)
	  return
	  >
	call bufrd
	cmp r0,#'(
	if ne,<
	  call bufrrd
	  sub clocat,r4
	  sub .lenth,r4
	  sub #2,r4
	  bis #67,2(sp)
	  br appval
	  >
	call appval
	bis #60,2(sp)
1$:	bis #40,2(sp)
2$:	call getreg
	bis r4,2(sp)
	call bufrd
	cmp r0,#')
	bne 3$
	bit #60,2(sp)
	if eq,<
	  call bufrd
	  cmp r0,#'+
	  if ne,<
	    bis #10,2(sp)
	    jcall bufrrd
	    >
	  bis #20,2(sp)
	  >
	return
3$:	jbr err

appval:	mov .lenth,r0
	mov r4,val(r0)
	add #2,.lenth
	return


val:	.word 0,0,0
.lenth:	.word 0

.sbttl	Expression reader

; EXP
exp:	call term
	pop r2,r4
loop <	  call bufrd
	  cmp r0,#40		; space, binary plus
	  beq 1$
	  cmp r0,#'+
	  if eq,<		; +, binary plus
1$:	    call term
	    bis (sp)+,r2
	    add (sp)+,r4
	    rptl
	    >
	  cmp r0,#'-
	  if eq,<		; -, binary minus
	    call term
	    bis (sp)+,r2
	    sub (sp)+,r4
	    rptl
	    >
	  >
	bit #%ndef,r2
	bne %err
	jcall bufrrd		; reread unknown character


; TERM
term:	push (sp),(sp)		; make slots for return vals
	push r2,r3		; save regs
	call fact
	pop 6+2(sp),r3
loop <	  call bufrd
	  cmp r0,#'*
	  if eq,<		; *, binary multiply
	    call fact
	    bis (sp)+,6+2(sp)
	    mul (sp)+,r3
	    rptl
	    >
	  cmp r0,#'!
	  if eq,<		; !, binary divide
	    call fact
	    bis (sp)+,6+2(sp)
	    clr r2
	    div (sp)+,r2
	    mov r2,r3
	    rptl
	    >
	  >
	call bufrrd		; reread unknown character
	mov r3,10(sp)
	pop r3,r2		; restore regs
	return


; FACT
fact:	push (sp),(sp)		; make two result slots
	clr 2(sp)		; clear flags word
3$:	call rnumbr		; see if numeric
	pop 4+2(sp),*
	beq 2$			; numeric, return value
	call bufrd		; get input character
	cmp r0,#'+
	beq 3$			; unary plus, ignore it
	cmp r0,#'-
	if eq,<			; -, unary minus
	  call fact
	  pop 2+2(sp),4(sp)
	  neg 4(sp)
2$:	  return
	  >
	cmp r0,#''
	if eq,<			; ', read ascii byte
	  call bufrd
	  mov r0,4(sp)
	  return
	  >
	cmp r0,#'"
	if eq,<			; ", read ascii word
	  call bufrd
	  movb r0,4(sp)
	  call bufrd
	  movb r0,5(sp)
	  return
	  >
	cmp r0,#'&
	if eq,<			; &, read rad50 word
	  call get50
	  pop 4(sp)
	  return
	  >
	cmp r0,#33		; check for Escape just so we can implment $Q
	if eq,<
	  call bufrdu		; read one more ahead
	  cmp r0,#'Q		; is it $Q
	  if eq,<		; yes, evalutes to last value typed out
	    mov cvalue,4(sp)
;	    mov cvflgs,2(sp)
	    return
	    >
	  call bufrrd		; wasn't $Q, put the char back
	  >
	call bufrrd		; reread the character for RR50
	jsr r5,rr50		; start of symbol?
	  br 1$
	call bufrrd		; reread the character for GSYM
	call gsym		; read symbol
	call svalue		; get symbol value
	pop 2+2(sp),4(sp)	; store results
	return
; character not the start of a factor so return null value
1$:	mov #%nilv,2(sp)	; null flag
	return			; and return


; RNUMBR, reads a number
; On return, SP -> numberP flag,
;		   value
rnumbr:	push (sp),(sp)		; create two result slots
	push r0,r1,r2		; save regs
	mov #%nilv,12(sp)	; initially no number
	clr r1
	clr r2
loop <	  call bufrd		; get input character
	  sub #'0,r0		; digit?
	  exitl lo
	  cmp r0,#9
	  exitl hi
	  ash #3,r2
	  add r0,r2
	  mul #10.,r1
	  add r0,r1
	  clr 12(sp)
	  rptl
	  >
	cmp r0,#'.-'0
	if eq,<
	  tst 12(sp)
	  bne 1$
	  mov r1,10(sp)
	  >
	else <
1$:	  mov r2,10(sp)
	  call bufrrd
	  >
	pop r2,r1,r0		; restore regs
	return


; GSYM reads a symbol, converting it to rad50.
; smashes R1
;	VALS:			  ARGS:
; reads own input	    S1 -> first word of rad50 symbol
;			    S2 -> second word of rad50 symbol
gsym:	call get50		; read 1st word of rad50
	pop s1			; copy result to return slot
	call get50		; read 2nd word of rad50
	pop s2			; copy result to return slot
loop <	  jsr r5,rr50		; read rad50 characters till no more
	    return		; return for character not rad50
	  rptl
	  >


; GET50 reads up to 3 rad50 characters and packs them into a word.
get50:	push (sp),r1		; make result slot, save reg
	clr 4(sp)		; init rad50 word
	jsr r5,rr50		; read rad50 character
	  br 1$
	mul #50*50,r1		; store in 1st position in word
	add r1,4(sp)		; ...
	jsr r5,rr50		; read rad50 character
	  br 1$
	mul #50,r1		; store in 2nd position in word
	add r1,4(sp)		; ...
	jsr r5,rr50		; read rad50 character
	  br 1$
	add r1,4(sp)		; store in 3rd position in word
1$:	pop r1			; restore reg
	return


; RR50 reads a ascii character and converts it to rad50.  If the
; character is not rad50 RR50 doesn't skip and character is left
; to be reread.  Character is left in R1.
rr50:	call bufrdu		; read upper case ascii character
	mov #47,r1		; no, search through rad50 table backwards
loop <	  cmpb r0,r50asc(r1)	; got a match
	  beq 5$		; yes.
	  sorl r1		; try next char
	  >			; if we fall through, char was not in table
; Hmm. apparently space isn't supposed to be part of rad50
;	cmpb r0,#40		; but space isn't in table, however, its value
;	beq 5$			; just happens to be zero, so..
	call bufrrd		; put character back to be reread
	rts r5			; take first return
5$:	tst (r5)+		; char was good, take skip return
	rts r5

; This old rad50 routine took so much effor to work out I didn't have the
; heart to delete it.  -CBF
;	beq 1$
;	cmp r0,#'%
;	beq 2$
;	cmp r0,#'.
;	beq 3$
;	mov r0,r1		; numbers in comments below are octal
;	sub #'0,r1		; R1 = char-60 ('0)
;	blo 7$			; char < 60, not rad50 by now
;	cmp r1,#9.		; ('0-'9)? 60<=char<=72? 0<=R1<=12?
;	blos 4$			; yes, R1+36 (char-60+36) is a rad50 number
;	sub #'A-'0,r1		; R1 = R1-21 (char-101)
;	blo 7$			; 72<char<101, not rad50
;	cmp r1,#'Z-'A		; (A-Z)? 101<=char<=132? 0<=R1<=31?
;	blos 5$			; yes, R1+1 (char-101+1) is a rad50 alpha
;7$:	call bufrrd		; reread the last character
;	rts r5
;1$:	add #33-35,r1		; $, rad50 = 33
;2$:	inc r1			; %, rad50 = 35
;3$:	add #34-36,r1		; ., rad50 = 34
;4$:	add #36-1,r1		; 0-9, rad50 = 36-47
;5$:	inc r1			; A-Z, rad50 =  1-32
;	tst (r5)+		; return2
;	rts r5


; SVALUE looks up symbol in S1 (2 words).  SFLGP is left pointing to the
; register flag word in the symbol table for this symbol.  SBIT will have
; a bit mask to specify the flag bit for this symbol in the flag words.
; On return, SP -> flags,
;		   value
svalue:	push (sp),(sp)		; make room for return vals
	push r1			; save reg
	clr 6(sp)		; if not found return zero
	mov #%ndef,4(sp)	; with undefined bit set
	mov stbeg,r1		; ptr to before 1st symbol's value word
	clr sbit
loop <	  sub #6,r1		; move ptr to next symbol
	  cmp r1,stend		; beyond end of symbol table?
	  exitl los		; not found
	  asl sbit		; get its bit in flag words
	  if eq,<		; move to next group of 16 symbols
	    inc sbit		; set bit 1 for first symbol
	    mov r1,sflgp	; save ptr to register flag word
	    cmp -(r1),-(r1)	; move ptr over flag words to value cell
				; of first symbol
	    >
	  cmp -4(r1),s1		; 1st word of rad50 same?
	  rptl ne
	  cmp -2(r1),s2		; 2nd word of rad50 same?
	  rptl ne
	  mov (r1),6(sp)	; found symbol, store value
	  clr 4(sp)		; flag word
	  bit sbit,@sflgp	; register value?
	  if ne,<
	    bis #%regv,4(sp)	; yes, set register flag in flag word
	    >
	  >
	mov r1,sptr		; save ptr to symbol entry
	pop r1			; restore reg
	return

sptr:	.word 0
sbit:	.word 0
sflgp:	.word 0
s1:	.word 0
s2:	.word 0

.sbttl	Symbol typeout

; SYM is like SYMBOL but checks absolute/relative typeout mode first
sym:	tst tabsmd		; absolute mode?
	bne const
	; fall through to symbol

; SYMBOL searches the symbol table for a value greater than or equal
; to the lookup value such that the difference is smaller than 200.
; Types out SYMBOL+OFFSET from looked up value.
;	ARGS:			VALS:
; SP -> flag	            S1/ symbol name
;	value

symbol:	push r0,r1,r2,r3,r4	; save registers
	clr s1			; will still be zero if nothing found
	mov stbeg,r1		; ptr to start of symbol table
	clr r2			; value of last symbol found
	clr r3			; bit in flag word for current symbol
loop <	  sub #6,r1		; move ptr to next symbol
	  cmp r1,stend		; check for end of symbol table
	  exitl los
	  asl r3		; next bit
	  if eq,<		; if 16 symbols then get new flag words
	    inc r3		; set bit 1 for first symbol
	    mov r1,r4		; save ptr to register flag word
	    cmp -(r1),-(r1)	; move ptr to before first symbol in this group
	    >
	  bit r3,-2(r4)		; if half killed then ignore it
	  rptl ne
	  mov 16(sp),r0		; get value
	  sub (r1),r0		; compare symbol's value to lookup value
	  rptl lo		; no good if smaller
	  cmp r0,mxoff		; no good if difference is large
	  rptl hi
	  cmp (r1),r2		; no good if smaller than largest found
	  rptl lo
	  bit #%regv,14(sp)	; symbol's reg flag must = value's
	  if eq,<
	    bit r3,(r4)		; lookup value is not register
	    rptl ne
	    >
	  else <
	    bit r3,(r4)		; lookup value is register
	    rptl eq
	    tst r0		; no offsets used for register typeout
	    rptl ne
	    >
	  mov -4(r1),s1		; save symbol name
	  mov -2(r1),s2		; ...
	  mov (r1),r2		; and value
	  rptl
	  >
	tst s1			; if zero, no symbol found
	if ne,<
	  call type50		; type symbol name
	  mov 16(sp),r0		; lookup value
	  sub r2,r0		; calculate offset from symbol value
	  beq 1$		; don't type offset if 0
	  printc '+
	  call tnumbr		; type octal of r0
	  >
	else <
	  push 16(sp),14+2(sp)	; CONST args: value, flags
	  call const		; type value as a constant
	  >
1$:	pop r4,r3,r2,r1,r0	; restore regs
	pop (sp),(sp)		; remove args from stack
	return


; CONST types its arg as a constant.  First arg is value, second is
; flag word.
const:	bit #%regv,2(sp)	; register value?
	if ne,<
	  printc '%		; % to indicate register value
	  >
	mov 4(sp),r0		; value arg
	pop (sp),(sp)		; remove args from stack
;	jcall tnumbr		; type as octal no.

.sbttl	Typeout routines

; TNUMBR: type out number in R0, do not smash it
; (Previous page falls through.)
tnumbr:	push r0			; save reg
	call 1$
	pop r0			; restore reg
	cmp tradix,#10.
	if eq,<
	  printc '.		; decimal, follow typeout with point
	  >
	return

1$:	push r1			; save reg
	mov r0,r1		; setup for DIV instruction, ugh
	clr r0			; ...
	div tradix,r0		; stuff left to type in r0, this digit in r1
	if ne,<
	  call 1$		; output higher digits
	  >
	mov r1,r0		; make ascii
	add #'0,r0		; ...
	pop r1			; restore reg
	jcall typec		; type it


; TYPE50 converts S1 and S2 from RAD50 to ASCII typeout
type50:	push r0,r1		; save regs
	mov s1,r1		; first word of RAD50
	call unpack
	mov s2,r1		; second word of RAD50
	call unpack
	pop r1,r0		; restore regs
	return

unpack:	clr r0			; get first char in r0
	div #50*50,r0		; ...
	movb r50asc(r0),r0	; convert first to ascii
	if ne,<
	  call typec		; type if not null
	  >
	clr r0			; get second char in r0, third in r1
	div #50,r0		; ...
	movb r50asc(r0),r0	; convert second to ascii
	if ne,<
	  call typec		; type if not null
	  >
	movb r50asc(r1),r0	; convert third to ascii
	if ne,<
	  jcall typec		; type if not null
	  >
	return

r50asc:	.byte 0			; ignore spaces
	.ascii "ABCDEFGHIJKLMNOPQRSTUVWXYZ$.%0123456789"
	.even

.sbttl	Input buffering and rubout processing

buf:	.blkb 78.	;buffer to store characters in
	.even
bufptr:	buf		;pts to next char to read in buf.
buflst:	buf		;pts to next open slot in buf (bufptr may
			;be less than buflst if currently
			;rereading chars).
bufpc:	-1		;place to goto if rubout found. (backup)
bufsp:	-1		;stack ptr if rubout found.

;BUFRD reads a  char (input or  from buf).  If  bufptr=buflst
;then a  char is  inputted,  echoed, and  put into  buf.   If
;bufptr<buflst then bufptr is moved and the next char is read
;from buf.  If  a rubout  is inputted, then  BUFRD will  loop
;inputting chars (handling rubout processing, deleting  chars
;from buf) until a non-rubout is found. That char is inserted
;into buf, bufptr is reset to the beginning of buf, and  then
;the program backs up  by setting PC from  bufpc and SP  from
;bufsp.  These were set by a previous call to BUFCLR.  Thus a
;rubout causes the program to back up and reread all previous
;chars not rubbed out.

; Note: BUFCLR, BUFRD, and BUFRRD are called with CALL .

; Note: BUFCLR should only be called by a top-level routine,
; not a subroutine.

bufclr:	mov (sp),bufpc		;save where to back up to.
	mov sp,bufsp		;save stack ptr (will have PC on top).
	mov #buf,bufptr		;clear out any chars in buf.
	mov #buf,buflst
	return

; BUFRDU - call bufd and upper case any alphabetic characters
bufrdu:	call bufrd
	cmp r0,#'a		; upper case alphabetic chars
	if his,<
	  cmp r0,#'z
	  if los,<
	    add #'A-'a,r0
	    >
	  >
	return

bufrd:	cmp bufptr,buflst	; input or reread?
	if lo,<
	  movb @bufptr,r0	; reread char
	  inc bufptr		; advance to next character
	  return
	  >
1$:	call readc		; read next character
	cmpb r0,#177		; rubout?
	if eq,<			; yes
	  cmp buflst,#buf	; rubout at beginning of buffer?
	  if los,<
	    printc 7		; beg of buf, so beep (Nothing to rub out)
	    br 1$
	    >
	  dec buflst		; forget about last character in buffer
	  movb @buflst,r0	; get character just rubbed out
	  call rubout		; erase it from display
	  mov #buf-1,bufptr	; reset ptr so reread characters (-1 so it is
				; incremented to BUF when we return from
				; BUFCLR call)
	  mov bufsp,sp		; now backup stack...
	  mov bufpc,(sp)	;   ... and PC
	  br 1$
	  >
	cmp r0,#014		; ^L?
	if eq,<
	  call clrscn		; clear screeen
	  push r1		; save reg
	  mov #buf,r1		; ptr to input buffer
  loop <    cmp r1,buflst	; typed everything in buffer yet?
	    exitl eq
	    movb (r1)+,r0	; get next char in input buffer
	    call typec		; type it
	    rptl
	    >
	  pop r1		; restore reg
	  br 1$			; get next input character
	  >
	movb r0,@buflst		; put char into bufffer
	inc buflst		; move to new char slot
	br bufrd		; go return char


bufpek:	call bufrd
;	br bufrrd

; BUFRRD causes the last character read to be reread.
bufrrd:	dec bufptr
	movb @bufptr,r0
	return


; RUBOUT does rubout echoing/erasing for char in R0.
rubout:
.if ne  asmttp
	tst ttytyp		; printing terminal?
	if eq,<
	  jcall typec		; yes, echo character
	  >
.endc
	cmpb r0,#40		; control char?
	if lo,<
	  cmpb r0,#33		; escape is only one char
	  if ne,<
	    call (pc)		; execute rest of this subroutine twice, i.e.
				; rubout two character positions
	    >
	  >
	jsr r5,types		; rub out char
	  bsspbs
	return

bsspbs:	.byte 10,40,10,0	; BS, SP, BS
	.even

.sbttl	Input-output routines.

; READC gets a character from the terminal.  The char is returned in r0.
readc:	call ireadc		; get a character
.if ne  asmttp
	tst ttytyp		; TTY?
	if eq,<
	  cmp r0,#'}		; yes, translate } to escape
	  if eq,<
	    mov #33,r0
	    >	  
	  >
.endc
	tst r0			; throw away nulls since probably
	beq readc		; garbage command anyway
	cmpb #15,r0 		; don't echo cr, lf, or rubout
	beq 2$
	cmpb #12,r0
	beq 2$
	cmpb #177,r0
	beq 2$
	call typec 		; echo character
	cmpb r0,#4		; ^D
	beq wipe
	cmpb r0,#7		; ^G
	beq quit
2$:	return

wipe:	print ^" XXX? "
	jbr rcd1
quit:	print ^"QUIT? "
	jbr rcd1


; IREADC reads a char from the terminal.
ireadc:	mov ttycsr,r0
loop <	  tstb (r0)
	  rptl pl
	  >
	mov 2(r0),r0		; get character
	bic #177600,r0		; strip off parity etc.
	return

.sbttl	Output subroutines

crlf:	print ^"
"
	return


; Clears screen for display, <CRLF> for TTY or Glass TTY
.if eq asmttp
clrscn==crlf
.iff
clrscn:	tst ttytyp
	ble crlf
	sout ^"HJ"
	return
.endc


; TYPES takes a pointer to an asciz string following the call and
; types the string.
types:	push r0,r1		; save regs
	mov (r5)+,r1		; pointer to asciz msg
loop <	  movb (r1)+,r0		; next character
	  exitl eq		; null terminates
	  call typec		; type char
	  rptl
	  >
	pop r1,r0		; restore regs
	rts r5


.if ne  asmttp
; ITYPES takes a pointer to an asciz string following the call and
; image types the string.
itypes:	push r0,r1		; save regs
	mov (r5)+,r1		; pointer to string
loop <	  movb (r1)+,r0		; get character
	  exitl eq		; null terminates
	  call itypec		; type char
	  rptl
	  >
	pop r1,r0		; restore regs
	rts r5
.endc


ctypec:	push r0
	mov (r5)+,r0
	call typec
	pop r0
	rts r5


; Type character contained in r0
typec:	cmpb r0,#40		; control character?
	bhis tyco4		; no, just print it
	cmpb r0,#7		; BELL?
	beq itypec
.if eq  asmttp
	cmpb r0,#10
	beq itypec
	cmpb r0,#15
	beq itypec
	cmpb r0,#12
	beq itypec
.endc
	push r0			; save char
.if ne  asmttp
	cmpb r0,#10		; BS?
	if eq,<
	  dec hpos
	  br tyco2
	  >
	cmpb r0,#11		; TAB?
	if eq,<
	  mov #40,r0		; type spaces to simulate
  loop <    call itypec
	    inc hpos
	    bit #7,hpos		; until reach multiple of 8
	    rptl ne
	    >
	  br tyco3
	  >
	cmpb r0,#12		; LF?
	if eq,<
	  call itypec		; type LF
	  tst ttytyp		; printing terminal or glass TTY?
	  ble tyco3		; yes, just type
	  sout ^"K"		; erase to end of line
	  br tyco3
	  >
	cmpb r0,#15		; CR?
	if eq,<
	  clr hpos
	  br tyco2
	  >
.endc
	cmpb r0,#33		; ESC?
	if eq,<
	  mov #'$,r0
	  br tyco1
	  >
	mov #'^,r0
	call tyco4
	mov (sp),r0
	bis #100,r0
tyco1:
.lif ne  asmttp
	inc hpos
tyco2:	call itypec
tyco3:	pop r0			; restore reg
	return


tyco4:
.lif ne  asmttp
	inc hpos

itypec:	push r1			; save reg
	mov ttycsr,r1
loop <	  tstb 4(r1)		; wait for ready
	  rptl pl		; ...
	  >
	movb r0,6(r1)		; send character
	pop r1			; restore reg
	return

.sbttl	Program memory access routines

.if eq  asmmap

getw:	mov @2(sp),2(sp)	; get desired word
	return

getb:	movb @2(sp),2(sp)	; get byte
	clrb 3(sp)
	return


putw:	mov 2(sp),@4(sp)	; try deposit
putw1:	pop (sp),(sp)		; remove args
	return

putb:	movb 2(sp),@4(sp)	; try deposit
	br putw1

.iff

getw:	push 2(sp)
	call map
	mov @(sp)+,2(sp)
	return

getb:	push 2(sp)
	call map
	movb @(sp)+,2(sp)
	clrb 3(sp)
	return

putw:	push 4(sp)
	call map
	mov 2+2(sp),@(sp)+
	pop (sp),(sp)
	return

putb:	push 4(sp)
	call map
	movb 2+2(sp),@(sp)+
	pop (sp),(sp)
	return

map:	push r0			; save register
	mov 4(sp),r0		; save program address
	bic #160000,4(sp)	; remove page number from address
	add #winvpg*8192.,4(sp)	; insert window page number
.if ne 1
	ash #-12.,r0		; extract page number *2 from program address
	bic #177761,r0		; ...
	mov uipar(r0),@#winpar	; point window at user's page
.iff
	ash #-13.+7,r0		; convert page number to block number
	bic #176177,r0		; ...
	cmp r0,#1600		; user page 7?
	if eq,<			; yes
	  mov #177600,r0	; use device register page instead
	  >
	mov r0,@#winpar		; point window at user's page
.endc
	pop r0			; restore register
	return
.endc

.sbttl	Instruction Symbol Table

; SYMBOL TABLE -- RAD50, THEN VALUE
; TO CHANGE MASK AND JUMP HAVE 0 HIGH BYTE IN 1ST RAD50 WORD
; FOLLOWED BY NEW MASK AND JUMP LOC
; IF FOLLOWED BY ZERO RIGHT BYTE, NEXT SYMBOL IS 2 WORDS LONG

.macro	instgroup mask,in,out
.iif ne <in-out>&177400, .error Instruction routine lossage
	.word in-out,mask,out
.endm

INSTS:	instgroup 107777,inop2,arith
	.RAD50 /MOV/
	010000
	.RAD50 /CMP/
	020000
	.RAD50 /BIT/
	030000
	.RAD50 /BIC/
	040000
	.RAD50 /BIS/
	050000

;ADD&SUB DO NOT HAVE BYTE OPTION SO ARE SEPERATE
	instgroup 007777,inop2,arith
	.RAD50 /ADD/
	060000
	.RAD50 /SUB/
	160000

;SINGLE OPERAND INSTRUCTIONS
	instgroup 100077,inop1,singop
	.RAD50 /CLR/
	005000
	.RAD50 /COM/
	005100
	.RAD50 /INC/
	005200
	.RAD50 /DEC/
	005300
	.RAD50 /NEG/
	005400
	.RAD50 /ADC/
	005500
	.RAD50 /SBC/
	005600
	.RAD50 /TST/
	005700
	.RAD50 /ROR/
	006000
	.RAD50 /ROL/
	006100
	.RAD50 /ASR/
	006200
	.RAD50 /ASL/
	006300


; single operand, non-byte, instructions
	instgroup 000077,inop1,singop
	.RAD50 /JMP/
	000100
	0			; signals instruction with >3 chars
	.RAD50 /B  /
	.RAD50 /SWA/
	000300

.if ne  pdp11-10
.if ne  pdp11-20
	.RAD50 /SXT/
	006700
.if eq  <pdp11-03>*<pdp11-23>*<pdp11-34>
	0
	.RAD50 /S/
	.RAD50 /MTP/
	106400
	0
	.RAD50 /S/
	.RAD50 /MFP/
	106700
.endc	; eq <pdp11-03>*<pdp11-23>*<pdp11-34>
.if ne  memman
	0
	.rad50 /I/
	.rad50 /MFP/
	006500
	0
	.rad50 /I/
	.rad50 /MTP/
	006600
	0
	.rad50 /D/
	.rad50 /MFP/
	106500
	0
	.rad50 /D/
	.rad50 /MTP/
	106600
.endc	; ne memman
.endc	; ne pdp11-20
.endc	; ne pdp11-10


;CONDITION CODES
	instgroup 000017,inccdd,cndcod
	.RAD50 /SE /
	000260
	.RAD50 /CL /
	000240

;RTS
	instgroup 000007,inrts,.rts
	.RAD50 /RTS/
	000200

;JSR/XOR
	instgroup 000777,injsr,.jsr
	.RAD50 /JSR/
	004000
.if ne  pdp11-10
.if ne  pdp11-20
	.rad50 /XOR/
	074000
.endc	; ne pdp11-20
.endc	; ne pdp11-10

.if ne  eis
;EIS
	instgroup 000777,ineis,.eis
	.rad50 /MUL/
	070000
	.rad50 /DIV/
	071000
	.rad50 /ASH/
	072000
	0
	.rad50 /C/
	.rad50 /ASH/
	073000
.endc	; ne eis

;CONTROL GROUP
	instgroup 0,incntr,.cntrl
	0
	.RAD50 /T  /
	.RAD50 /HAL/
	0
	0
	.RAD50 /T  /
	.RAD50 /WAI/
	1
	.RAD50 /RTI/
	2
	.RAD50 /BPT/
	3
	.RAD50 /IOT/
	4
	0
	.RAD50 /ET /
	.RAD50 /RES/
	5
.if ne  pdp11-10
.if ne  pdp11-20
	.RAD50 /RTT/
	6
.endc
.endc
	.RAD50 /NOP/
	240

;TRAP AND EMT
	instgroup 377,intrap,.trap
	.RAD50 /EMT/
	104000
	0
	.RAD50 /P  /
	.RAD50 /TRA/
	104400

;BRANCHES
	instgroup 377,inbrch,.brchs
	.RAD50 /BR /
	000400
	.RAD50 /BNE/
	001000
	.RAD50 /BEQ/
	001400
	.RAD50 /BGE/
	002000
	.RAD50 /BLT/
	002400
	.RAD50 /BGT/
	003000
	.RAD50 /BLE/
	003400
	.RAD50 /BPL/
	100000
	.RAD50 /BMI/
	100400
	.RAD50 /BHI/
	101000
	0
	.RAD50 /S  /
	.RAD50 /BLO/
	101400
	.RAD50 /BVC/
	102000
	.RAD50 /BVS/
	102400
	.RAD50 /BCC/
	103000
	0
	.rad50 /S  /
	.rad50 /BHI/
	103000
	.RAD50 /BCS/
	103400
	.rad50 /BLO/
	103400

; SOB
	instgroup 777,insob,.sob
	.rad50 /SOB/
inste:	077000

	constants		;Constants area goes here
				;(Strings and other literals)

.sbttl	Command dispatch tables

comls1:	.byte	033	;  $    alt
	.byte	':	;  :   colon	starts command name.
	.byte	'=	;  =   equal
	.byte	';	;  ;   semicn
	.byte	'@	;  @   openpc	opens location addressed by PC
	.byte	'>	;  >   define
	.byte	'/	;  /   oword
	.byte	'\	;  \   obyte
	.byte	'[	;  [   onum
	.byte	']	;  ]   osym
	.byte	015	;  CR  cr
	.byte	012	;  LF  lf
	.byte	011	; TAB  tab
	.byte	'^	;  ^   up
	.byte	'	;  ^N		single step
	.byte	'_	;  _		type $q in symbolic mode
	.lif ne  asmRT1+asmsrl
	.byte	'L	;  $L  load	Load
	.lif ne  asmdmp
	.byte	'Y	;  $Y  dump	Dump
	.byte	'G	;  $G  go	Go
	.byte	'W	;  $W  wsearc	Word search
	.byte	'N	;  $N  nsearc	Not Equal word search
	.byte	'E	;  $E  esearc	Effective addr search
	.byte	'B	;  $B  setbpt	Breakpoint
	.byte	'P	;  $P  proced	Proceed
	.byte	'U	;  $U  delb	Remove breakpoint
	.byte	'K	;  $K  kill	Half kill
	.byte	'Z	;  $Z  zero	Zero core
	.byte	'O	;  $O  soct	Set octal output radix
	.byte	'D	;  $D  sdec	Set decimal output radix
	.byte	'C	;  $C  cmode	Constant typeout mode
	.byte	'S	;  $S  smode	Symbol typeout mode
	.byte	'I	;  $I  imode	Instruction typeout mode
	.byte	'"	;  $"  amode	Ascii typeout mode
	.byte	'&	;  $&  rmode	Rad50 typeout mode
	.byte	'`	;  $`  cmodeb	Constant typeout mode (byte)
	.byte	''	;  $'  amodeb	Ascii typeout mode (byte)
	.byte	'A	;  $A  absmd	Absolute typeout mode
	.byte	'R	;  $R  relmd	Relative typeout mode
ncom==.-comls1		; no. of commands
	.byte	0	; place to stick search terminator
	.even

; Address of command routines
comls2:	alt	;  $  signals command
	colon	;  :  followed by command name
	equal	;  =  prints current value
	semicn	;  ;  retype $q in last specified mode
	openpc	;  @  opens location addressed by PC
	define	;  >  defines sym
	oword	;  /  open word in current core
	obyte	;  \  open byte
	onum	;  [  open as number
	osym	;  ]  open as symbol
	cr	;  CR close
	lf	;  LF close, open next
	tab	; TAB open location addressed by .
	up	;  ^  close, open previous
	sstep	;  ^N single step
	tysymb	;  _  Type $q in symbolic mode
	.lif ne  asmRT1+asmsrl
	load	;  L  Load
	.lif ne  asmdmp
	dump	;  D  Dump
	go	;  G  Go
	wsearc	;  W  Word search
	nsearc	;  N  Not Equal word search
	esearc	;  E  Effective addr search
	setbpt	;  B  Set Breakpoint
	proced	;  P  Proceed
	delb	;  U  Delete breakpoint
	kill	;  K  Kill symbol
	zero	;  Z  Zero core
	soct	;  O  Set octal typeout radix
	sdec	;  D  Set decimal typeout radix
	cmode	;  C  Constant typeout mode
	smode	;  S  Symbolic typeout mode
	imode	;  I  Instruction typeout mode
	amode	;  "  Ascii typeout mode
	rmode	;  &  Rad50 typeout mode
	cmodeb	;  `  Constant typeout mode (byte)
	amodeb	;  '  Ascii typeout mode (byte)
	absmd	;  A  Absolute typeout mode
	relmd	;  R  Relative typeout mode
.iif ne  <.-comls2>/2-ncom, .error Command tables not same length
	err	;  illegal command


;Table of routine-pointers for colon commands:
;Terminated by -1, an illegal rad50 word.
coltab:	.rad50 "help  "		; list : commands
	  .word colhlp
.if ne asmrt1
	.rad50 "exit  "		; return to RT-11
	  .word exit
.endc
	.rad50 "listb "		; list breakpoints
	  .word	listb
	.word 0			; terminator

.sbttl	Data

; mode data
tabsmd:	.word 0		; temporary absolute/relative typeout mode
pabsmd:	.word 0		; permanent absolute/relative typeout mode
semimd:	.word tycons	; semi-colon mode
twmode:	.word tyinst	; temporary location typeout mode (word)
pwmode:	.word tyinst	; permanent location typeout mode (word)
tbmode:	.word tybcon	; temporary location typeout mode (byte)
pbmode:	.word tybcon	; permanent location typeout mode (byte)

tradix:	.word 8.	; temporary output radix
pradix:	.word 8.	; permanent output radix

altcnt:	.word 0		; no of alts in command


; current location
clflgs:	.word 0		; current location flags (register flag)
caddr:	.word 0		; used only by OPEN and CLOSE
o.bw:	.word 0		; 0 - closed, 1 - byte open, 2 - word open
oo.bw:	.word 0		; old o.bw for next ^ or LF command


; command argument
argcnt:	.word 0


; current value
length:	.word 0		; length of current value
cvalue:	.word 0,0,0	; current value
cvflgs:	.word 0		; current value flags (register flag)


; breakpoint data
bptset:	.word 0		;-1 if breakpoints set
bptno:	.word -1	;no. of last breakpoint
bptadr:	.rept nbpt
	-1
	.endr
bptcnt:	.blkw nbpt
bptins:	.blkw nbpt


proflg:	.word 0		; set to single step once, then proceed
ssflag:	.word 0		; nonzero if single stepping
count:	.word 0		; single step count

starta:	.word 0		; program start address


; terminal data
ttycsr:	.word trs
.if ne  asmttp
.iif ndf  %tntyp,	%tntyp===%tngl
ttytyp: .word %tntyp
hpos:	.word 0			; output column pointer
.endc

.if ne asmsrl+asmRT1
srlcsr:	.word trs
errcnt:	.word 0		; number of checksum errors per load
.endc

smask:	.word -1	; search mask
dmplow:	.word 0		; low limit (for both searchs and dumps)
dmphi:	.word symtop	; high limit


; symbol table
stbeg:	.word rugsa-2+6	; ptr to one symbol beyond first register flag word
stend:	.word symtop	; ptr to symbol slot beyond last in table

; This word defines how far from a symbol a number has to be before it will
; not use the form: <symbol>+offset for printing.
mxoff:	.word 1000

.sbttl	User-Register Storage

; The order of the following entries is critical

uregs:	0	; user r0
	0	;      r1
	0	;      r2
	0	;      r3
	0	;      r4
	0	;      r5
usp:	0	; user sp
upc:	0	; user pc

nuregs==<.-uregs>/2


; List of locations saved while in RUG.  RUG saves the locations in the
; program being debugged which it clobbers so that they may be restored
; when the program is continued.
.macro	save loc,symbol,init	; macro to generate save table entries
	.word loc
symbol:	.word init
.endm

savls1:	save 177776,ups		; this entry exists for user interaction, it
				; is saved/restored specially
savls2:	;; entries here are ignored by loading
savls3:	save 4,sv4,trap4
	save 6,sv6,pr7
	.word 0			; this terminates the list

.if ne asmrt1
savls4:	save 4,1$		; NXM trap vector
	save 6,2$		; ...
	save 10,3$		; illegal instruction trap vector
	save 12,4$		; ...
	save trs+0,5$		; initial tty receiver csr
	save trs+4,6$		; initial tty transmitter csr
	save icvec+0,10$	; TTY receiver interrupt vector
	save icvec+2,11$	; ...
	save icvec+4,12$	; TTY transmitter interrupt vector
	save icvec+6,13$	; ...
	save 100,14$		; clock interrupt vector
	save 102,15$		; ...
	.word 0
.endc

svrcsr:	.word 0

	.blkw 60.	; stack area
stack==.


lastlc==.-2	; highest RUG location

.sbttl	Symbol Table

; The following macro produces symbol-table entries.  The symbol table grows
; downward from BSYMT (below RUG) in groups of 16 symbols (the last, lowest
; group is padded with null entries).  Every 16-sym group is followed by 2
; flag words whose bits specify which of the 16  symbols are half-killed
; (lower word), and which are registers.  The low-order bit in each flag
; corresponds to the symbol entry with the highest address (for that 16
; symbol group).  The flags are stored in two temporaries, %.rflg and %.hflg,
; until the 16 symbol group is done.  They are then put into their core
; locations.

; The macro S takes four arguments: NAME is the symbol name (it may be any
; length but is entered in the symbol table as 6 letters), VALUE is the
; symbol value, FLAG1 and FLAG2 may be "HK" and/or "REG" (or neither) to
; signify that the symbol is to be half-killed or is a register.  Some
; examples: "S FOO,1,HK" or "S FOO,1,REG,HK" or "S FOO,1,HK,REG". After all
; symbols, terminate with the macro ENDS.

; A symbol entry is 3 words: two words of rad50 name (up to
; 6 letters) followed by a value word.

	%.rflg===0	; temp reg flags word
	%.hflg===0	; temp half-kill flags word
	%.sbit===0	; flag bit for current symbol in group
	%.rmask===0	; masks conditional register flag on or
	.lif ne asmmap	; off depending on value of asmmap
	%.rmask===177777

.macro	s name,value,flag1,flag2,flag3

	.if eq  %.sbit
	  .=.-4-<16.*6>		; starting a new block, move down
	  %.sbit===100000
	  .endc

	%.stmp===.
	.rad50 /name/
	%.slng===.length name
	.iif le  %.slng-3,	.word 0
	.iif gt  %.slng-6,	.=%.stmp+4
	.word value

	.irp flag,<flag1,flag2,flag3>
	  .iif idn flag,hk,	%.hflg===%.hflg!%.sbit
	  .iif idn flag,HK,	%.hflg===%.hflg!%.sbit
	  .iif idn flag,reg,	%.rflg===%.rflg!%.sbit
	  .iif idn flag,REG,	%.rflg===%.rflg!%.sbit
	  .iif idn flag,cndreg,	%.rflg===%.rflg!<%.sbit&%.rmask>
	  .iif idn flag,CNDREG,	%.rflg===%.rflg!<%.sbit&%.rmask>
	  .endm

	%.sbit===<%.sbit/2>&077777
	.if eq	%.sbit
	  .word	%.hflg,%.rflg
	  .=.-4-<16.*6>
	  %.hflg===0
	  %.rflg===0
	  .endc
.endm s

.macro	ends
	.if ne  %.sbit
	.rept 16.
	  .if ne  %.sbit
	    .word 0,0,0
	    %.sbit===<%.sbit/2>&077777
	    %.hflg===%.hflg!%.sbit	; half-kill empty slots
	    .endc
	  .endr
	.word %.hflg,%.rflg
	.=.-4-<16.*6>
	.endc
.endm ends

.=rugsa		; start symbol table just below start of RUG
	s %0,0,reg
	s %1,1,reg
	s %2,2,reg
	s %3,3,reg
	s %4,4,reg
	s %5,5,reg
	s %6,6,reg
	s %7,7,reg
clocat=.+4	;where dot's value is stored
	s .,0,hk		; current location
	s .m,smask,hk,cndreg	; search mask
.lif ne  asmttp
	s .ttyty,ttytyp,hk,cndreg	; tty type code
	s .stbeg,stbeg,hk,cndreg	; ptr to top of symbol table
	s .stend,stend,hk,cndreg	; ptr to bottom of symbol table
	s .start,starta,hk,cndreg	; start address of program
	s .bptno,bptno,hk,cndreg	; last breakpoint no.
	s .mxoff,mxoff,hk,cndreg	; Maximum offset from a symbol
.lif ne asmmap
	s .kipar,uipar,hk,cndreg	; User's mappings registers
.if ne <asmrt1+asmsrl>*asmdmp
	s .dmplo,dmplow,hk,cndreg	; low address to dump
	s .dmphi,dmphi,hk,cndreg	; high address to dump
.endc
	ends


symtop==.-2		; top of user symbol table


	.if2
	.print "
Highest RUG location = "
	typval \lastlc
	.print "
Top of user symbol table = "
	typval \symtop
	.print "
"
	.endc

.end rug
