;;; -*-PALX-*-
%cncp2===%fnam2

.title NCP for the Chaos Network

;;; PDP-11 Network Control Program (NCP) for the Chaos Network

;;; Derived from CHSGTV;NNCP 71 written by JLK for the Plasma
;;; Grinnel TV System by OTA and LSP starting on Dec. 11, 1979.

;;; Using this NCP:

;;; The general approach to initialization is as follows:
;;;
;;; Every program that includes the NCP is expected to provide a storage
;;; allocator for packets that provides the following entry points:
;;;
;;; alcsiz	-  Allocate a packet given the size in r3.  Return pointer
;;;		   to packet in r0.
;;; alc16	-  Allocate a 16 word packet.  Return pointer in r0.
;;; alc32	-  Ditto for 32 words.
;;; alc64	-  Ditto for 64 words.
;;; alc128	-  Ditto for 128 words.
;;; alc256	-  Ditto for 256 words.
;;;
;;; The allocation routines return with the C bit set to indicate failure
;;; return a new packet.  The method of partitioning memory is unimportant
;;; to the NCP.
;;;
;;; The NCP also expects certain macros to be defined which specify the
;;; proper configuration of the host machine.  These are:
;;;
;;;
;;;	The INFACE macro which defines the CIF table
;;;	specifying the configuration of hardware
;;;	interfaces that reside on the host whose NCP is
;;;	being assembled.
;;;
;;;	The RCVXMT macro which defines the code for the
;;;	particular hardware interfaces on this host.
;;;
;;; The CHAOS NCP will invoke these macros at the appropriate
;;; places to create the storage for the various tables as well
;;; as place the transmitter and receiver routines.
;;;
;;; In addition, the NCP requires a tasking environment.  The NCP
;;; consists of three tasks: the receive task, the transmit task and
;;; the clock driven task.  The exact interface to this environment
;;; is defined by conditional assembly of the NCP.  Currently
;;; supported are the LSP/OTA Arpa world (and soon the CBF Grinell
;;; system.)  The NCP minimally requires a task scheduler that saves
;;; and restores all the registers, stack state saved between
;;; schedule intervals, and task create/delete routines. 

;;; The NCP provides the entry CHINIT which should be called to
;;; re-initialize and re-start the network.  CHINIT will create and
;;; start the tasks for the NCP.

;;; User programs interface to this NCP primarily via the routines:

;;; chlsn	-  Requests that the NCP listen for a given contact name
;;;		   User supplies a contact name and a connection openning
;;;		   routine.
;;; chrfc	-  Requests that the NCP initiate a connection.
;;;		   User supplies a contact name, destination host, and
;;;		   a few other things.  The routine return when the connection
;;;		   opens.
;;; cheof	-  Transmit an EOF packet on a connection
;;; chdati	-  Receive input on a given connection
;;; chdato	-  Transmit output on a given connection
;;; chfini	-  Finish all outstanding transmissions.
;;; chcls	-  Closes and frees a connection.  This is called both
;;;		   when a connection is noticed to have closed by the
;;;		   user to clean things up and when the user wants to
;;;		   terminate a connection.

;;; If these routines fail for any of a number of reasons (usually because
;;; there are no packets available of an adequate size), they will return
;;; with the C bit set.  More documentation on the arguments, etc. for
;;; these routines can be found immediately preceeding them.

;;; PRELIMINARIES

.iif ndf $$wait, $$wait===0	;use TASKM style waiting
.iif ndf rt11fg, rt11fg===0	;not an RT-11 assembly

;;; Load packages needed and not yet loaded elsewhere

;;; load standard macros
.iif ndf cbfdfs, .insrt defs
.iif ndf arpmac, .insrt dcls

;;; load chaos net symbol definitions
.iif ndf caicsr, .insrt chsdfs

;;; Define symbols needed and can optionally be defined externally

.iif ndf ncons,  ncons===30.	;maximum number of connections
.iif ndf mxrtrn, mxrtrn===4	;maximum # of interrupt retransmissions
.iif ndf lsnmax, lsnmax===6	;maximum number of LSN pkts to queue up
.iif ndf ticktm, ticktm===1	;conversion from 60.ths to chaos ticks
.iif ndf ackwait, ackwait===6./ticktm	; wait this long before giving up on
					; piggy backing an ack (.1 second)
.iif ndf rcpwait, rcpwait===9./ticktm	; wait this long before giving up and
					; sending a receipt (.15 second)
.iif ndf prbrat, prbrat===<5.*60.>/ticktm	;approx rate to send probes
.iif ndf snsrat, snsrat===<30.*60.>/ticktm	;the time to wait before
						;sending sense anyway
.iif ndf uprat,  uprat===<125.*60.>/ticktm	;if no response in 125. secs,
						;declare it dead.
.iif ndf rfctim, rfctim===<2.*60.>/ticktm	;frequency of RFCs
.iif ndf charto, charto===<25.*60.>/ticktm	; time out for arpa connections
.iif ndf chchto, chchto===<3.*60.>/ticktm	; time out for chaos conns
; .iif ndf maxtry, maxtry===3.			;number of times to try to RFC
.iif ndf agetim, agetim===<4.*60.>/ticktm	;frequency of routing aging
.iif ndf ruttim, ruttim===<15.*60.>/ticktm	;frequency of RUT packets
.iif ndf mintim, mintim===ackwait/2	;min(ackwait, rcpwait, prbrat, snsrat)/2
					;which is how often to check for
					;probing, sensing, and statusing
.iif ndf mxsbnt, mxsbnt==100	; number of supported subnets


;;; Macro for computing pointers to connection variables for connection in r1

.macro	conptr var,dest
	mov r1,dest
	add #var,dest
.endm

;;; Macro for checking for valid packets.  Used sometimes when debugging.

.macro	chkpak
.endm

	.sbttl Packet Definitions

;;; Conventions used in the NCP.

; The first slot of a packet is a link field which is used by packets that
; are part of a list, or it must be zero if the packet is not on a list.
; The next slot is for debugging and contains the address of the call
; to the packet allocator that created the packet, or, if the packet is on
; a free storage list, the address of the call to packet releasing routine.
; The next slot is used for aging items on certain lists, followed by
; a slot used to indicate the type (usage) of a packet in the low byte.

; Packet types: (type is stored in the pktyp byte of the packet)
    %ptlsn===4			;packet defining a task waiting for a conn.
    %ptsrv===10			;packet defining a task to be created to
				;an incomming RFC.

; Register Usage:
;    r0 - normally holds pointer to an untyped packet or a chaos net packet.
;    r1 - pointer to a connection packet
;    r2 - temporary
;    r3 - often used to hold counts
;    r4 - temporary
;    r5 - temporary

;;; Chaos Net packet definitions

dsect <
pklnk::	 .blkw 1		;the link for the packet lists (must = 0!)
pktim::	 .blkw 1		;retransmission time
	 .blkw 1		;unused

;;; NOTE: the above fields are overlapped with the hardware fields used
;;; by the Chaos net interface.  There can be no more than 3 words here
;;; unless the maximum packet size is made larger.  Here starts the
;;; software header.

pkbeg::
pktyp::	 .blkb 1		;the packet type (byte - internal use only)
pkop::	 .blkb 1		;the opcode (byte address)
pklen::	 .blkw 1		;the length word
pkdhst:: .blkw 1		;the destination host number
pkdidx:: .blkw 1		;the destination index number
pkshst:: .blkw 1		;the source host number
pksidx:: .blkw 1		;the source index number
pkpkn::	 .blkw 1		;the packet number
pkakn::	 .blkw 1		;the acknowledge number
pkdat::	 .blkw 1		;the start of data in the packet
	>

pkfcnt==170000			;this is the forward count field
pkfcni==010000			;increment fowarding count with this

pkmasz==512.			;The full length of the largest packet
;pkmdsz==pkmasz-pkdat		;This is the maximum number of data bytes
pkmdsz==488.			;Actually this is.  2 bytes are not used
				; because of PDP10 strangeness

;;; Symbols used in LSN packets (%ptlsn and %ptsrv)

dsect <
	 .blkb pkpkn
lsnadr:: .blkw 1		;address of where to put the RFC packet if
				;it is a %ptlsn type listen or the address
				;of the routine to start a task at.  In the 
				;later case the RFC packet will be in r0.
lsncon:: .blkw 1
lsnctn:: .blkw 1		;beginning of the contact name string
	>
lsnrfc==lsnadr

;;; Connection packet symbols

dsect <
	 .blkw 1		;connection link (used for connection lists)
cnrcnt:: .blkw 1		;reference count
cnact::	 .blkw 1		;the last time that something was received on
				;this connection
cnact2:: .blkw 1		;last time that something was sent or received
				; on this connection
cnstat:: .blkw 1		;status of the connection
   cnios==cnstat+1		;I/O status
cnfhst:: .blkw 1		;the foreign host number
   cnfnet==cnfhst+1		;the foreign net number
cnfidx:: .blkw 1		;the foreign host index
cnlidx:: .blkw 1		;the local index of the connection
   cnlunq==cnlidx+1		;uniquizer field
trwsiz:: .blkw 1		;transmit side window size
rcwsiz:: .blkw 1		;receive side window size

;;; Transmit side
trpkn::	 .blkw 1		;packet number for the next controlled packet
				;that we will send on this connection
trackn:: .blkw 1		;packet number that foreign host has
				;acknowledged
trrcvl:: .blkw 1		;list of packets awaiting receipts
trrcvn:: .blkw 1		;packet number foreign host has receipted

;;; Receive side
rcols::	 .blkw 1		;ordered list of packets for the user to read
rcolse:: .blkw 1		;pointer to last packet on RCOLS
rcuols:: .blkw 1		;the unordered list of packets read
rcsrcp:: .blkw 1		;packet number that should be receipted
rcrcps:: .blkw 1		;packet number that has been receipted
rcsack:: .blkw 1		;packet number that should be acknowledged
rcacks:: .blkw 1		;packet number that has been acknowledged
rcasiz:: .blkw 1		;point at which an ack is in order

cnrcpt:: .blkw 1		;time when a receipt needs to be sent
cnackt:: .blkw 1		;time when an ack needs to be sent
cnrtim:: .blkw 1		;response time in 1/60th times 8

;;; Meters
cnrtsc:: .blkw 1		;retransmitted because of statuses
cnrttc:: .blkw 1		;retransmitted because of time outs.
cndupk:: .blkw 1		;duplicate packets received
cnrsts:: .blkw 1		;received status packets
cntsts:: .blkw 1		;transmitted status packets
cnrsns:: .blkw 1		;SNS packets received on connection
cntsns:: .blkw 1		;SNS packets transmitted on connection
	>,cn.ln



;;; Routing table and definitions

maxage===1024.			;maximum aging of route table costs
%rtdir===1			;direct routing type
%rtbrg===2			;bridge routing type
%rtfbr===3			;fixed bridge routing type

	.sbttl CHSRCV - Chaos NCP Receiver Task

;;; CHSRCV - This is the code run by the Chaos NCP Receiver Task

chsrcv:

;;; Init the random value for unikey.

	mov clock,r0		;init unikey by waiting for the clock to tick
	mov #10000.,r1		;count down 10000. times
loop  <	cmp r0,clock		;values still the same?
	exitl ne		;exit if not
	sorl r1			;loop
	>
	add r1,unikey		;make the key random
	tstb unikey		;and the low byte non-zero
	if eq,< inc unikey>

;;; If any interrupts came from devices that don't want to read out
;;; packets at interrupt level.  TTYs do not have this problem since
;;; their characters come in one at a time and the finished packet
;;; is queued on the list.

cabrk:	cocall
	mov #ciftbl,r2		;get ready to loop through the interfaces
1$:	bit #%rcvrd,ci.sts(r2)	;does this rcvr need servicing?
	beq 2$			;no, go to next interface
	 mov ci.rcv(r2),r0	;get the receive handler
	 beq 2$			;no handler (why is bit set?)
	 kcall (r0)		;read packet out of interface onto rcvr list
2$:	add #cif.ln,r2		;go to next interface
	cmp r2,#cifend
	blo 1$

	lock mxcilv
	mov rcvpkl,r0		;get the first packet to "receive"
	beq 3$			;no packets so just sleep
	 mov (r0),rcvpkl	;unthread packet from list
	 bne 5$
	  mov #rcvpkl,rcvpke	;the list is empty
5$:	 unlock
	 clr (r0)
	 kcall caibrk		;process this packet
	 br cabrk
3$:	unlock
	br cabrk

	.sbttl Process a packet from the Network


caibrk:	cmp pkdhst(r0),myhost	; is this packet for me?
	bne caforw		; no, forward it to another host
.iif ne %codat-200, .error ; This code loses
	movb pkop(r0),r4	; get the opcode of this packet
	cmpb r4,#%comax		; check opcode
	bge caibop		; if %COMAX le OPCODE lt 200 then it is illegal
	if his,<		; if OPCODE gt 200
	  jcall chidat		; then data packet
	  >
	asl r4			; turn into a word index
	jcall @chidis(r4)	; dispatch on type

caibop:	mov #bopmsg,r2		; no, send a bad opcode msg
	br calose


;;; Dispatch Table for various packet opcodes

chidis:	chinul			;null opcode {01/2~
	chirfc			;rfc opcode
	chiopn			;open opcode
	chicls			;close opcode
	chifwd			;forward opcode
	chians			;answer opcode
	chisns			;sense status opcode
	chists			;status opcode
	chirut			;routing opcode
	chilos			;loss opcode
	chilsn			;listen opcode
	chimnt			;maintenance opcode
	chieof			;eof opcode
	chiunc			;uncontrolled data opcode

.iif nz %comax-<<.-chidis>/2>, .error chidis wrong length

;;; Handle various functions of incoming control packets

;;; Here the recieved packet is not for us, so just send it a long
;;; to the next guy if the forwarding count has not been exceeded.

caforw:	cmpb pkop(r0),#%corut	; routing packet?
	if eq,<			; yes, should have ignored address
	  jmp chirut
	  >
	add #pkfcni,pklen(r0)	;increment fowarding count {/~
	bit #pkfcnt,pklen(r0)	;is count now all zero's (e.g. overflow)?
	bne catran		;no, so transmit it
	inc caovfw		;count over forwarded packets
	;; fall into free packet routine

;;; This return frees the packet in r0 if it is no longer needed.

caifpk:	jcall frepck


;;; Here the packet is a loss some how, so send it back as a LOS
;;; r2 holds pointer to the explanation (asciz string)

calose:	cmpb #%colos,pkop(r0)	;was it already a loss?
	beq caifpk		;yes, just return, freeing packet
	movb #%colos,pkop(r0)	;recycle the packet. Set the type to LOS
	kcall strcp0		;copy the msg into the packet (ignore error)
	;; falls through to send the packet

;;; CALOSE and CHIOPN come here in order to get the dest. and src fields
;;; swapped.  CATRAN is called directly by CAFORW.

caret:	exch pkdidx(r0),pksidx(r0),r2	;interchange src and dest index
	exch pkdhst(r0),pkshst(r0),r2	;and host address for recycled packets
	;; falls through

;;; Queue a packet for transmission (e.g. caforw)

catran:	clr pktim(r0)		;set time for detecting retransmission
	clr (r0)
	mov r0,@chtpke		;link it onto the transmit list
	mov r0,chtpke
	kretrn

;;; Subroutine to check for open connection for received packet.
chicpk:	clr r3			; get low byte of local index for this packet
	bisb pkdidx(r0),r3	; ...
	cmp r3,#ncons		; in range?
	bhis 6$			; no
	asl r3			; turn it into a word index
	mov contbl(r3),r1	; get the connection packet for that index
	beq 6$			; no such connection
	cmp pkdidx(r0),cnlidx(r1)	; make sure the indicies are the same
	bne 6$
	cmpb cnstat(r1),#%csopn	; is the connection open?
	bhi 3$			; no [this is weird]
	mov clock,cnact(r1)	; the time that something was received
	mov clock,cnact2(r1)	; the time that something was received
	kretrn
3$:	tst (sp)+		; throw away return address
	mov #cclmsg,r2		; no, send "connection closed" msg
	br calose
6$:	tst (sp)+		; throw away return address
	mov #bimsg,r2		; no, send bad index msg
	br calose

	.sbttl Received Control Packet Handlers

;;; In general r0 is the packet pointer, and r1 points to a connection packet

;;; NUL, LSN - Both opcodes are illegal when received from the net.

chilsn==caibop			;for internal use by NCP only!
chinul==caibop			;what is this for?


;;; MNT - Ignore.

chimnt==caifpk


;;; OPN - The other end is responding to our RFC, agreeing to open
;;;       the connection.

chiopn:	kcall chicpk
	cmpb #%csrfs,cnstat(r1)	;we should be in rfc sent state {01/2~
	beq 1$			;if so, continue below
	 cmpb #%csopn,cnstat(r1)	;else, was the connection open?
	 beq caifpk		;yes, just ignore it (index ok'd in caibrk)
	  mov #bstmsg,r2	;no, send a bad state message
	  jcall calose		;in a LOS packet
1$:	movb #%csopn,cnstat(r1)	;record that the connection is open
	clrb cnios(r1)		;i/o state is open in both directions
	mov pksidx(r0),cnfidx(r1)	;set up the foreign index from the OPN
	mov pkpkn(r0),r3	;the first packet number minus 1
	mov r3,rcacks(r1)	;the last packet received and acked
	mov r3,rcsack(r1)	;last packet we received
	mov r3,rcsrcp(r1)	;the last packet number received in order
	mov r3,rcrcps(r1)	; the last packet we've receipted
	mov pkdat+2(r0),trwsiz(r1)	;set the window size
	inc caopns		;count connections opened.
	kcall maksts		;fill in STS packet {01/2~
	jcall caret		;and send it by turning around

;;; SNS - Other end is trying to probe us to see if we are alive.
;;;       Respond by sending a STS (status) packet informing him of our state.

chisns:	kcall chicpk
	inc cnrsns(r1)		;count SNS packets received on this connection
	inc casnst		;count STS's evoked by SNS's
chisn0:	kcall frepck		;free the SNS
	jcall sndsts		;send the STS


;;; STS - Received connection status info from the remote end.
;;;       R3 holds the packet receipt number as an argument to
;;;       caircp.

chists:	kcall chicpk
	inc cnrsts(r1)		;count received status packets
	mov pkdat+2(r0),r3	;get the window size requested
;	cmp r3,trwsiz(r1)	;compare with the current window size
;	if gt,<
;	 bicb #%iosow,cnios(r1)	;clear output waiting since size has increased
;	 >
	mov r3,trwsiz(r1)	;set the window size
	mov pkdat+0(r0),r3	;get number to have received {01/2~
	cmpb #%csopn,cnstat(r1)	;is the connection open?
	bne 2$			;no, skip the receipt processing
	 kcall caircp		;yes, handle receipts (number in r3). Uses r0
2$:	kcall chrtrn		;retransmit all the packets that need it
	jcall frepck		;and free the STS packet in r0


;;; FWD, ANS, CLS - Treated the same - passed to user level.

chifwd:
chians:				;answer opcode {01/~
chicls:				;and close opcode are all the same
	kcall chicpk
	movb #%cscls,cnstat(r1)
;	jcall clsque		;turn it into a message

;;; Queue a close type packet in r0.

clsque:	clr (r0)		;clear the link field
	mov r0,@rcolse(r1)	;put on receive list
	mov r0,rcolse(r1)	;new end
;	bicb #%iosow,cnios(r1)	;enable input
	kretrn


;;; LOS - Connection lost somehow

chilos:	kcall chicpk
	cmpb #%cscls,cnstat(r1)	;already closed?
	beq 1$			;yes, just ignore it.
	 mov trrcvl(r1),r2
	 kcall frelst		;free the packets waiting receipts
	 clr trrcvl(r1)		;free these only once
	 movb #%cslos,cnstat(r1)	;closed by LOSsage
	 movb #%cocls,pkop(r0)	;pass up to user only close pkts
	 jcall clsque
1$:	jcall frepck		;and free the packet



;;; UNC - Handle like a data packet (but no ack or receipt hacking)
;;;       and it goes right on the front of the list.

chiunc:	kcall chicpk
	mov rcols(r1),(r0)	;link in on the front of the list
	mov r0,rcols(r1)
;	bicb #%iosiw,cnios(r1)	;clear the input wait
	kretrn


;;; RUT -  Routing added by OTA and LSP on 1/5/83 at the SIPB Office

chirut:	mov r0,r2		;make a temporary pointer into the packet
	add #pkdat,r2		;data area
	mov pklen(r0),r3	;get the packet byte count
	bic #pkfcnt,r3		;clear forwarding count (should be 0, but
				; we've had problems!!)
	asr r3			;divide by 4
	asr r3
	if ne,<
  loop <    mov (r2)+,r4	;get subnet this bridge can get to
	    cmp r4,#mxsbnt
	    if lo,<
	      cmpb #%rtbrg,chrtyp(r4)	;if this is not a bridged net
	      if eq,<
		asl r4			;*2 for word indexing
		cmp chrcst(r4),(r2)	;compare the cost
		if his,<
		  mov (r2),chrcst(r4)	;update the cost value
		  mov pkshst(r0),chradr(r4)	;update the host address of bridge
		  >
		>
	      >
	    tst (r2)+
	    sorl r3
	    >
	  >
	jcall frepck

;;; RFC - Process the RFC by seeing if a connection is already open.  This
;;;	  implies that the last open we sent was lost so resend the OPN.
;;;	  If no connection exists then search the list of LSN packets
;;;	  for one with a contact name that matches.  If none is found
;;;	  reject the RFC with a close.  If a LSN is found with a matching
;;;	  contact name that listen is processed.  This involves either
;;;	  creating a task or waking an existing task to handle the RFC.
;;;	  Task creating LSNs stay around until explicitly deleted but
;;;	  LSNs for existing tasks are deleted when they get used.

chirfc:	mov #contbl,r3		;does the requested connection exist already?
	mov #ciimsg,r2		;error msg if we lose
4$:	mov (r3)+,r1		;search the connection table to find out
	beq 5$			;connection index unused
	cmpb #%cscls,cnstat(r1)	;if connection is closed just assume it's gone
	beq 5$
	cmp pkshst(r0),cnfhst(r1)	;same host?
	bne 5$			;no, continue looking
	cmp pksidx(r0),cnfidx(r1)	;is this the right connection?
	bne 5$			;nope
	cmpb #%csopn,cnstat(r1)	;is it in open state?
	bne 1$			;no
	 tst trackn(r1)		;is the connection new still?
	 bne 2$			;no, this must be a spurious RFC
	 tst rcacks(r1)
	 bne 2$
	  mov rcwsiz(r1),r4	;already exists, resend an open
	  jcall sndopn
2$:	 jmp calose		;report the spurious RFC
1$:	jcall frepck		;just ignore the rfc we will reply in due time
5$:	cmp r3,#<ncons*2>+contbl	;done?
	blo 4$			;no, loop

;;; Now check for contact names being listened for.
;;; Register usage: r0 - incoming RFC packet, r1 - current LSN packet,
;;; r2 - previous LSN packet, r3 - RFC string pointer, r4 - LSN string pointer
;;; r5 - Byte count of RFC data

	mov #chlsnl,r1		;pointer to LSN list
lsnlp:	mov r1,r2		;r2 gets pointer to previous item on LSN list
	mov (r2),r1		;r1 gets pointer to next item on LSN list
	beq rfclos		;end of list, contact name not found
	mov r0,r3		;r3 gets ptr to the contact name in RFC pkt
	add #pkdat,r3
	mov pklen(r0),r5	;r5 gets data byte count
	bic #pkfcnt,r5		;clear out all but the count
	mov r1,r4		;r4 gets ptr to the contact name in LSN pkt
	add #lsnctn,r4
1$:	cmpb (r3)+,(r4)+	;do string compare on contact names
	bne lsnlp		;not equal, so go try the next LSN packet
	tstb (r4)		;at the end of the LSN contact name?
	beq 2$			;yes, go see if we have a match
	 dec r5			;no.  See if we looked at last char of RFC pkt
	 ble lsnlp		;if so, RFC pkt contact name was too short
	 cmpb #40,(r3)		;space terminates contact name in RFC pkt
	 beq lsnlp		;if space, the RFC pkt name was too short
	  br 1$			;continue the string compare
2$:	cmpb #40,(r3)		;space terminates contact name
	beq lsnprc		;packet name terminated also, so win
	 sob r5,lsnlp		;if cnt didn't run out, RFC pkt name too long

;;; Here, we have found a LSN pkt with a contact name matching that in the RFC
;;; pkt.  Using the info in the LSN packet either create a task and give it
;;; the RFC pkt in r0 and the connection in r1, or put the RFC pkt and the
;;; connection in the specified locations, which wakes up a waiting task.

lsnprc:	mov r1,r3		;save the LSN pkt in r3
	kcall allcon		;allocate a connection
	bne 3$
	 mov #noconn,r2		;can't win so inform other side
	 clr pklen(r0)
	 br rfclo1		;and refuse the connection
3$:	movb #%csrfc,cnstat(r1)	;it has received an RFC
	mov pkshst(r0),cnfhst(r1)	;set foreign hst in index
	mov pksidx(r0),cnfidx(r1)
	cmpb #%ptlsn,pktyp(r3)	;Is it the wake up the task type?
	bne 1$
	 mov r0,@lsnrfc(r3)	;put RFC ptr where he said to.
	 mov r1,@lsncon(r3)	;put the connection where he said to.
	 mov (r3),(r2)		;thread us out of the list
	 mov r3,r0		;and free the packet
	 jcall frepck
1$:	call crtask,<r0,r1,#0,#0,#0,#0,lsnadr(r3)>,r2
				;create a task to handle things
	bcc 2$
	 mov #sflmsg,r2		;can't create a task so tell him system full
	 clr pklen(r0)		;flush data in RFC packet
	 kcall rlscon		;free the connection we just grabbed
	 br rfclo1		;send the close with explain
2$:	kretrn

rfclos:	mov #unkctn,r2		;pointer to unknown contact name message
rfclo1:	kcall strcpy		;copy it into the packet (ignore errors)
	movb #%cocls,pkop(r0)	;set the packet type to a close
	clr pkdidx(r0)		;indicate there is no connection
	jcall caret

;;; Handle packet receipting

;;; This expects r0 to point to a packet, it handles the setting of
;;; trrcvn and trackn.  Trackn gets set from the packet, and trrcvn
;;; (receipt number) gets set from r3.  Called from chists and chidat.

caircp:	cmp r3,trrcvn(r1)	;is the current receipt level LT new?
	if mi,<			; rcpt'ed a pkt number less than we think has
				; already been ACK'ed.
	  inc cauorp		;record for statistics
	  br 2$
	  >
	mov r3,trrcvn(r1)	;set receipt variable
	mov trrcvl(r1),r2	;get pointer to the list
	beq 2$			;no list
loop <	  cmp r3,pkpkn(r2)	;has this packet been received remotely?
	  exitl mi		;if yes, remove it from the retransmit list
	  push (r2)		;save pointer to next one
	  push r0		;save r0 to accomplish the freeing of the pkt
	  mov cnrtim(r1),r0	; get existing avg time
	  ash #-3,r0		; get 1/8th of it.
	  sub r0,cnrtim(r1)	; subtract that away.
	  mov clock,r0		; calculate the current response time
	  sub pktim(r2),r0
	  add r0,cnrtim(r1)	; add in the most recent response time
	  mov r2,r0
	  kcall frepck
	  pop r0,r2		;get back next one on list
	  rptl ne		;and loop back if we are not at the end (=0)
	  >
	mov r2,trrcvl(r1)	;set up new receive list

;;; Come here when done receipting packets on the retransmit list.
;;; Now check the acknowledgement status.

2$:	mov pkakn(r0),r4	;get the ack number for this packet {01/3~
	cmp trackn(r1),r4	;is the current level less than new?
	if mi,<			;yes
	  mov r4,trackn(r1)	;set it to the new one
	  >
	kretrn



;;; This retransmits all unreceipt'ed packets for the connection in r1.
;;; Called by chists.

chrtrn:	conptr trrcvl,r5	;make it absolute pointer to rexmt list {1/23~
2$:	mov (r5),r2		;get packet to retransmit
	beq 4$			;at the end of the list
	mov cnrtim(r1),r3	; R3: round trip time * 8
	add #17,r3		; divide by 16 (rounding up) to get
	ash #-4,r3		; one way time
	add pktim(r2),r3	;is it time yet?
	cmp r3,clock		;ok, retransmit it
	bmi 3$			;not ready yet
	 mov r2,r5		;pick up next item on the list
	 br 2$			;check the next packet
3$:	inc cnrtsc(r1)		;count of pkts retransmitted because of sts
	mov (r2),(r5)		;take it out of the retransmit list
	clr pktim(r2)		;clear the time of all these packets
	clr (r2)		;clear the link field
	mov r2,@chtpke
	mov r2,chtpke
	br 2$			;get the next packet
4$:	kretrn			;and return
	.sbttl Data Packet Handler

;;;  Process received data packets.
;;;  First check that the packet is both within the window and in order.
;;;  If not, throw it away or put it on the out of order list respectively.
;;;  Note, receiving packets outside the window implies buggy software
;;;  somewhere!

chieof::
chidat:	kcall chicpk		;R1: connection for this packet
	mov pkakn(r0),r3	;CAIRCP arg: R3/ receipt level
	kcall caircp		;process the ack in this packet
	mov pkpkn(r0),r3	;R3: packet number of this packet
	mov r3,r4		;R4: position in window
	sub rcacks(r1),r4	;...
	cmp r4,rcwsiz(r1)	;inside connection window size?
	if gt,<			;no
	  inc carwov		;record for stats
	  jcall frepck		;and free (to be fair to other connections)
	  >
	cmp r4,rcasiz(r1)	;in danger of filling window?
	if gt,<			;yes
	  cmp rcsack(r1),rcacks(r1)	;anything to ack?
	  if ne,<		;yes
	    mov clock,r4	;R4: 1/20 (.05) second from now
	    add #3/ticktm,r4	;...
	    cmp r4,cnackt(r1)	;planning to send an ack soon?
	    if mi,<		;no
	      mov r4,cnackt(r1)	;do so
	      >
	    >
	  >
	mov rcsrcp(r1),r4	;R4: last packet number
	cmp r4,r3		;is this a duplicate packet?
	bpl prcdpk		;yes, punt it
	inc r4			;is it the next packet?
	cmp r3,r4		;...
	bne prnord		;no, store on out-of-order list

	;; Now the packet has been validated and receipted, put it on the list
	;; of packets that have been properly received.  Then look on the
	;; out-of-order list to see if the first item on that list is now in
	;; order.

loop <	  clr (r0)
	  mov r0,@rcolse(r1)	;link it on the end of the list
	  mov r0,rcolse(r1)	;and set the new end of the list
	  cmp r0,rcols(r1)	;is the new packet the first on the list?
	  if eq,<		;yes
	    mov clock,cnrcpt(r1)	; start the rcpwait timer for sending
	    add #rcpwait,cnrcpt(r1)	; its receipt
	    >
	  inc r3		;next packet number
	  mov rcuols(r1),r0	;R0: next packet from out of order list
	  exitl eq		;none, done checking out-of-order packets
	  cmp pkpkn(r0),r3	;is it the next packet?
	  exitl ne		;no, done checking out-of-order packets
	  inc r4		;update received packet number
	  mov (r0),rcuols(r1)	;remove it from the out of order list
	  rptl			;go add it to ordered list
	  >
	mov r4,rcsrcp(r1)	;update received packet number
;	bicb #%iosiw,cnios(r1)	;clear the input wait
	kretrn

;;; Put a packet on the out-of-order list.  Assumes R3 has the packet number
;;; for packet in R0.

prnord:	conptr rcuols,r4	;get pointer to the place to link it in
1$:	mov r4,r5		;link down the list
	mov (r5),r4		;get pointer to next packet
	beq 2$			;at the end of the list
	 cmp r3,pkpkn(r4)	;is this where to put it?
	 beq prcdpk		;duplicate packet, dispose of it: send STS
	 bpl 1$			;no, not less than this packet, loop.
2$:	mov r4,(r0)		;get this packet's forward pointer
	mov r0,(r5)		;link it on the out of order list
	inc canord		;record statistics
	jcall sndsts		;send status on connection in r1

;;; Got a duplicate packet, the other end must be falling behind.

prcdpk:	inc cndupk(r1)		;count duplicate packets
	jcall chisn0		;and pretend we were a sense

.sbttl Transmit Packets

;;; Chaos NCP Transmit Task.
;;; Loop over all the transmitters.  If the transmitter has a finished
;;; packet in it then do the end game processing on that packet and
;;; reset the interface.  If the transmitter is ready search the transmit
;;; list for a packet going to a sub-net that uses this interface and
;;; send the packet out over the interface.

chsxmt:	mov #ciftbl,r2		;start with first interface
loop <	  bitb #%xmtrd,ci.sts(r2)	;is this interface ready for packets?
	  beq 1$		;no
	  mov ci.pkt(r2),r0	;get the packet it just sent
	  if ne,<		;if any
	    clr ci.pkt(r2)	;the interface is really ready now
	    bitb #%xmtab,ci.sts(r2)	;did this packet abort?
	    if ne,<			;yes
	      inc ci.abc(r2)	;increment abort count for this interface
	      cmp pktim(r0),#1	;did we transmit it only once?
	      if ne,<		;no, a retransmit abort
		inc ci.rab(r2)	;count it
		>
; This code can't work -- R4 not set for CATTR2.
;	      cmp pktim(r0),ci.mab(r2)	;too many retransmitions?
;	      if le,<			;no
;		kcall cattr2		;retransmit
;		br 1$
;		>
	      >
	    kcall ctpkdn	;do post-transmission processing on packet
	    >
	  kcall cattrn		;send next packet for this transmitter
1$:	  add #cif.ln,r2	;go to next transmitter
	  cmp r2,#cifend	;end of table?
	  rptl lo
	  >
	cocall
	br chsxmt

;;; CTPKDN handles to cleaning up of a packet after the xmtr is done with it.

ctpkdn:	mov r0,chtsav		;save for debugging
	cmp pkshst(r0),myhost	;did i originate this?
	bne catfre		;no, forwarded packet. Just throw it away
	movb pkop(r0),r3	;is it a control packet? (lt 200)
	bmi 10$			;no
	;; maybe a control packet
	cmpb r3,#%coopn		;test for exceptions: OPN, EOF
	beq 10$
	cmpb r3,#%coeof
	bne catfre
10$:	movb pksidx(r0),r3	;pick up the index number
	asl r3			;make into a word offset
	mov contbl(r3),r1	;get the connection packet
	beq catfre
	cmpb #%csopn,cnstat(r1)	;are we still open?
	bne catfre		;no, just throw this stuff away...
	cmp pksidx(r0),cnlidx(r1)	;check the indicies
	bne catfre		;different discard packet (bug ?)
	cmp trrcvn(r1),pkpkn(r0)	;has this one been received?
	bpl catfre		;yes, flush it
;;; Here link it on the list of packets waiting for receipts
;;; (this is still the previous packet - haven't gotten to the next one yet)
	mov clock,pktim(r0)	;set the retransmitted time
	conptr trrcvl,r5	;get pointer to the place to link it in
	mov pkpkn(r0),r3	;get the packet number
1$:	mov (r5),r4		;get pointer to next packet
	beq 3$			;none, just set it up
	 cmp r3,pkpkn(r4)	;is it less than this packet?
	 bmi 3$			;yes, just insert it here then
	 mov r4,r5		;cdr down the list
	 br 1$			;and go back
3$:	mov (r5),(r0)		;get this packet's forward pointer
	mov r0,(r5)		;link it on the receipt list
	kretrn

;;; come here to free the previous packet and continue
catfre:	jcall frepck

;;; Come here to get a packet off the transmit list and send it out
;;; over the network.  R2/ CIF table entry.

cattrn:	push r5			;save register
	mov #chtpak,r5		;R5: previous "packet"
loop <	  mov (r5),r0		;R0: next packet on list
	  if eq,<		;no more
	    pop r5		;restore register
	    kretrn		;none, just flush out of here
	    >
	  mov pkdhst(r0),r4	;R4: destination address
	  cmpb pkop(r0),#%corut	;routing packet?
	  if eq,<		;yes
	    cmpb pkshst+1(r0),ci.net(r2)	;for this subnet?
	    exitl eq				;yes
	    br 1$				;no, try next packet
	    >
	  movb pkdhst+1(r0),r3	;R3: destination subnet
	  cmpb r3,ci.net(r2)	;same subnet as interface?
	  exitl eq		;yes, send it
	  cmp r3,#mxsbnt	;larger than the max sub-net number?
	  if lo,<		;no, it's ok
	    asl r3		;word index into routing table
	    mov chradr(r3),r4	;R4: gateway to route packet to
	    if ne,<		;unknown sub net?
	      cmpb chradr+1(r3),ci.net(r2)	;is the gateway to the net on
						; this interface?
	      exitl eq		;yes, send this packet
1$:	      mov r0,r5		;no, get another packet
	      rptl
	      >
	    >
	  ;; can't get there from here
	  mov (r0),(r5)		;unthread the packet
	  if eq,<		;removed last packet in list?
	    mov r5,chtpke	; yes, update end pointer
	    >
	  clr (r0)
	  kcall ctpkdn		;try this pkt later, may be routing info then
	  rptl
	  >

	mov (r0),(r5)		;unthread the packet
	if eq,<			;removed last packet in list?
	  mov r5,chtpke		; yes, update end pointer
	  >
	clr (r0)
	pop r5			;restore register

;;; Transmit a packet in r0 (the abort case comes here too)

cattr2:	inc pktim(r0)		;increment number of times transmitted
	cmp pkshst(r0),myhost	;did i originate this?
	bne 1$			;no, skip acking
	mov pksidx(r0),r3	;check the whole index (including high byte)
	beq 1$			;=0: no real connection exists, skip acking
	movb r3,r3		;get the index
	asl r3
	mov contbl(r3),r1	;get the connection
	beq 1$			;not any more
	cmp cnlidx(r1),pksidx(r0)
	bne 1$
	mov rcsack(r1),r3	;get the level we should ack
	mov r3,pkakn(r0)	;put it into the packet
	tstb pkop(r0)		;data packet?
	bpl 1$			;no, skip ack hacking
	mov r3,rcacks(r1)	;say we acked this far
	cmp rcrcps(r1),r3	; we've receipted at least as far as we've
	if mi,<			; acked
	  mov r3,rcrcps(r1)
	  >
1$:	mov r0,ci.pkt(r2)	;save for ack processing
	jcall @ci.xmt(r2)	;transmit the packet (host is in r4)

.sbttl	Miscellaneous Utility Routines

;;; Sends a status on connection in r1, clobbers r0 and r2.
;;; Called from chidat, chscst, etc.  Ignored if no packets available.

sndsts:	kcall alc16		;get a 16 word packet (or larger)
	bcc 1$			;got it
	 kretrn			;lose, no packets
1$:	kcall setpck		;setup packet for transmission
	kcall maksts		;make up rest of packet
	inc cntsts(r1)		;count transmitted status packets
	jcall catran


;;; Assumes that the host and destination are correct,
;;; R0 points to a packet and R1 is the connection.

maksts:	inc casts		;increment number of statuses sent
	movb #%costs,pkop(r0)	;set in op code {01/2~
	mov #4,pklen(r0)	;set the length to 4 bytes
	add #pkpkn,r0		;get pointer to the packet number
	mov trpkn(r1),(r0)+	;put next packet number in packet
	mov rcsack(r1),(r0)	;put ack level in packet
	mov (r0)+,rcacks(r1)	;remember how far we've ack'd
	mov rcsrcp(r1),(r0)	;put receipt level in packet
	mov (r0)+,rcrcps(r1)	;remember how far we've receipted
	mov rcwsiz(r1),(r0)	;set in the window size we want
	sub #pkpkn+6,r0
	kretrn


;;; Sends a sense (probe) on connection in r1, clobbers r0 and r2.
;;; Called from the probe routine, chsprb.  Ignored if no pkts free.

sndsns:	kcall alc16		;get a 16 word packet (or larger)
	bcc 1$			;got it
	 kretrn			;lose, no packets
1$:	inc cntsns(r1)		;count SNS packets transmitted on connection
	movb #%cosns,pkop(r0)	;set opcode to SNS
	clr pklen(r0)		;no data
	kcall setpck		;fill in host and indices
	mov trpkn(r1),pkpkn(r0)	;put next packet number into packet
	mov rcacks(r1),pkakn(r0)	;put ack level into packet
	mov pkakn(r0),rcacks(r1)	;remember how far we've ack'd
	cmp rcrcps(r1),pkakn(r0)	; we've receipted at least as far as we've
	if mi,<				; ack'd
	  mov pkakn(r0),rcrcps(r1)	; ...
	  >
	inc casns		;number of sense packets sent
	jcall catran


;;; Setup the packet header for transmission by setting src, dest
;;; index and host fields.  Assumes a packet in r0, a connection
;;; in r1.

setpck:	clrb pktyp(r0)
	mov cnfhst(r1),pkdhst(r0)	;send in foreign host address and index
	mov cnfidx(r1),pkdidx(r0)
	mov myhost,pkshst(r0)		;my host, net and index
	mov cnlidx(r1),pksidx(r0)
	mov clock,cnact2(r1)	; set activity time to now
	kretrn

;;; Sends an OPN (open) on a connection.  An old RFC packet is assumed
;;; to be in r0, since the most common thing is to respond to a RFC
;;; by turning the packet into OPN and sending it back.  The only
;;; significance to this is that the source and destination fields
;;; get swapped and PKAKN is 1 minus PKPKN of first foreign data packet.
;;; The desired receive window size should be supplied in r4.

sndopn:	mov r4,rcwsiz(r1)	;set window size from the packet
	mov r4,pkdat+2(r0)	;store receive window size
	inc r4			; compute ceil(Rwin/2)
	asr r4			; ...
	mov r4,rcasiz(r1)	; for the time to send an ack
	movb #%csopn,cnstat(r1)	;set the opcode to OPN
	mov clock,cnact(r1)	;start activity timeouts
	mov clock,cnact2(r1)	;start activity timeouts
	mov pkshst(r0),cnfhst(r1)	;set foreign host and index
	mov pksidx(r0),cnfidx(r1)	;into this connection
	mov cnlidx(r1),pkdidx(r0)	;set dest index (words swapped later)
	mov pkpkn(r0),r4	;1- pkpkn of 1st foreign data packet
	mov r4,rcsrcp(r1)	;init our pk number variables
	mov r4,rcrcps(r1)
	mov r4,rcacks(r1)
	mov r4,rcsack(r1)
	mov r4,pkakn(r0)	;and ack the rfc packet
	mov r4,pkdat(r0)	;yes, the receipt field also...
	clr pkpkn(r0)		;might as well be 0 to start
	movb #%coopn,pkop(r0)	;opcode is OPN
	mov #4,pklen(r0)	;set data length (2 words, 4 bytes)
				;can lose if contact name less than 4 bytes!
	jcall trnpck		;transmit this packet
	.sbttl CHSCLK - Chaos Clock Monitoring Task

;;; This task is responsible for invoking the probing, sensing and timeout
;;; retransmission routines at the appropriate clock intervals.

chsclk:
loop <
.if eq $$wait
	mov clock,r5
	add #mintim,r5		;this is the time we next want to check
  loop <  cocall
	  cmp clock,r5
	  rptl mi
	  >
.iff
	push #mintim		; SLEEP arg: 60ths
	kcall sleep		; wakeup after MINTIM elapsed time
.endc

	cmp nxtage,clock	; time to age routing table?
	if mi,<			; yes
	  kcall chsage		; age it
	  mov clock,nxtage	; schedule again AGETIM ticks from now
	  add #agetim,nxtage	; ...
	  >

.iif gt cifcnt-1,	kcall chsrut		; send RUT

	clr r5			;R5: index through the connection table
loop <				;connection loop
	  mov contbl(r5),r1
	  if ne,<		;nothing there, so iterate
	    cmpb cnstat(r1),#%csopn	;is the connection open?
	    if eq,<		;yes, do clock chores for it
	      kcall chscst	;check on needed statuses
	      kcall chsrtn	;check on retransmissions
	      kcall chsprb	;check on the need to probe and sense
	      >
	    >
	  add #2,r5		; go to the next connection
	  cmp r5,#ncons*2	; end of connection table?
	  rptl lo		; check the next connection table slot
	  >
	rptl			; timer loop
	>

;;; Age data in the routing table.

chsage:	mov #chrcst,r3		;R3: pointer to routing cost table
	mov #chrtyp,r2		;R2: pointer to the type array
	mov #mxsbnt,r4		;R4: subnet count
loop <	  cmpb (r2)+,#%rtbrg	;bridge?
	  if eq,<
	    cmp (r3),#maxage
	    if lo,<
	      inc (r3)		;increment the cost
	      >
	    >
	  tst (r3)+		;point to next entry
	  sorl r4
	  >
	kretrn


.if gt cifcnt-1
;;; Send a RUT packet.

.iif gt mxsbnt-122.,	.error Too many subnets
;;; If there are ever more than 122 subnets, we will need to generate multiple
;;; RUT packets!
chsrut:	mov #ciftbl,r5		; R5: interface
loop <    cmp ci.rut(r5),clock	; time to send RUT?
	  bpl 2$		; no
	  mov #<mxsbnt*4+pkdat>/2,r3	; ALCSIZ arg: r3/ number of words
	  kcall alcsiz		; get RUT packet with room for each subnet
	  exitl cs		; try next pass if no memory
	  clrb pktyp(r0)
	  movb #%corut,pkop(r0)	; set opcode
	  clr pklen(r0)		; initialize length (increment later)
	  clr pkdhst(r0)	; broadcast
	  clr pkdidx(r0)	; not used
	  mov ci.hst(r5),pkshst(r0)	; this is our address on the subnet
	  clr pksidx(r0)	; not used
	  clr pkpkn(r0)		; not used
	  clr pkakn(r0)		; not used
	  mov #chrcst,r1	; R1: pointer to subnet cost table
	  mov r0,r3		; R3: pointer to next entry in RUT packet
	  add #pkdat,r3		; ...
	  clr r4		; R4: subnet number
  loop <    cmpb r4,ci.net(r5)	; we're not a bridge to the interface's subnet
	    beq 1$		; ...
	    cmpb chrtyp(r4),#%rtbrg	; access this subnet via a bridge?
	    if eq,<			; yes
	      cmpb chradr-chrcst+1(r1),r4	; is bridge on this same
						; subnet as interface?
	      beq 1$		; yes, we don't want to forward either
	      cmp (r1),#maxage	; route very old?
	      bhis 1$		; yes, don't offer to forward
	      >
	    ;; add route to RUT packet
	    add #4,pklen(r0)	; 2 more words
	    mov r4,(r3)+	; subnet numbet
	    mov (r1),(r3)	; cost is our cost
	    add ci.cst(r5),(r3)+	; plus cost of subnet
1$:	    tst (r1)+		; advance to next subnet
	    inc r4		; ...
	    cmp r4,#mxsbnt	; ...
	    rptl lo		; ...
	    >
	  kcall trnpc1		; transmit the RUT
	  mov clock,ci.rut(r5)	; schedule again RUTTIM ticks from now
	  add #ruttim,ci.rut(r5); ...
2$:	  add #cif.ln,r5	; advance to next interface
	  cmp r5,#cifend	; ...
	  rptl lo		; ...
	  >
	kretrn
.endc

;;; Check for connections that have un acked packets and send a status.
;;; r0,r2 are bashed

chscst:	cmp rcsack(r1),rcacks(r1)	; are the acks up to date?
	if ne,<
	  cmp cnackt(r1),clock	; is it time to send an ack on this connection?
	  if mi,<		; time and past time
	    jcall sndsts	; send it off: r0,r2 are bashed
	    >
	  >
	cmp rcsrcp(r1),rcrcps(r1)	; are there receipts to send?
	if ne,<			; yes
	  cmp cnrcpt(r1),clock	; has he waited long enough?
	  if mi,<		; yes
	    kcall sndsts	; send it: r0,r2 are bashed
	    >
	  >
	kretrn

;;; Check for packets that may need retransmission.

chsrtn:	mov r1,r4		;pointer to transmit receipt list var in r4
	add #trrcvl,r4		; ...
loop <
	  mov (r4),r0		;packet loop: get the next packet
	  exitl eq		;no more on this connection
	  mov cnrtim(r1),r2	; R2: round trip time * 8
	  add #3+6*4,r2		; rounding and 100ms before division
	  asr r2		; convert to round trip time * 2
	  asr r2		; + 100ms
	  add pktim(r0),r2	;get the time to retransmit
	  cmp r2,clock		;if packet time + age time has past then retransmit
	  if pl,<
	    mov r0,r4		;else move down the list
	    rptl		;and loop
	    >
	  ;; here we must retransmit packet in r0
	  inc cnrttc(r1)	;count pkts retrans. due to timeouts
	  clr pktim(r0)		;clear the time for abort counts
	  mov (r0),(r4)		;update list
	  clr (r0)
	  mov r0,@chtpke	;add to transmit list
	  mov r0,chtpke
	  rptl			;go back for next packet
				;(no need to update r4, it was rplacd'd)
	  >				    
	kretrn


;;;  Probing about every 5 seconds on connections that need acks.

chsprb:	mov clock,r3		;clock time for testing timeouts
	sub #uprat,r3		;nothing received for a very long time?
	cmp cnact(r1),r3	;...
	if mi,<			;nothing!  shut down connection
	  movb #%csinc,cnstat(r1)	;set state to incomplete transmission
	  mov #tmomsg,r2	;send a timeout message (probably won't do any
	  bcall pktmsg		; good)
	  >
	sub #snsrat-uprat,r3	;nothing sent or received for some time?
	cmp cnact2(r1),r3	;...
	if mi,<			;nothing
	  jcall sndsns		;send a SNS
	  >
	sub #prbrat-snsrat,r3	;time to probe if there are unack'd packets
	mov trackn(r1),r0	;the number of packet he has acked
	inc r0			;one larger is next packet
	cmp r0,trpkn(r1)	;has he acked all of them yet?
	if ne,<			;no
	  cmp cnact2(r1),r3	;no activity recently?
	  if mi,<		;none
	    kcall sndsns	;send a SNS
	    >
	  >
	kretrn

;;; Queue fake CLS on connection in r1.  r2 points an asciz explanation
;;; string.

pktmsg:	kcall alc32		;get a packet (32 should be enough, usually)
	bcs 1$
	movb #%cocls,pkop(r0)	;close type packet
	kcall strcp0		;size is checked here, don't care if it loses
	jcall clsque		;queue it
1$:	kretrn
	.sbttl User Interface

;;; The plan here is as follows:
;;; Packets are output via routines called CHOPEN (open a connection),
;;; CHDATI (input data), CHDATO (output data), CHEOF (eof on connection),
;;; CHANS (send an answer packet), CHCLS (close the connection),
;;; CHLSN (wait for a connection), CHRPLY (reply to RFC with OPEN),
;;; and CHSTAT (returns the status of a chaos connection).

;;; Control packets are always put immediately on the end of the transmit list
;;; while data packets are subject to waiting on the transmit window being
;;; full.  Routines return with C set if they fail (usually because no packets
;;; are available).  The user program is expected to check this.

;;; The arguments for each of the routines are outlined before the
;;; code for the routine.

;;; CHOPEN: Open a connection on the chaos net.  The arguments to it are
;;; the destination host number, the initial window size, the time out
;;; period (in 1/60ths of a second), and a string containing the contact
;;; name and JCL that is placed in the RFC.  The connection packet is
;;; returned if the open succeeds.  Otherwise, in general a CLS packet is
;;; returned whose data field contains an error message.

chopen:	proc 4,1,<r0,r1,r2,r3,r4>,<cotimo>
	clr out1(fp)
	kcall alc16		;get a packet for the RFC
	bcs colos2		;oops no packets, tough luck for the user
	mov #noconn,r4		;load up no connection msg in anticipation
	kcall allcon		;allocate a connection
	beq colos1		;oh well, this isn't our day, no connections
	mov arg1(fp),cnfhst(r1)	;move the host name into the connection
	movb #%csrfs,cnstat(r1)	;connection state is rfc-send
	clr cnfidx(r1)		;clear the destination connection index
	mov arg2(fp),r3		;put the window size in r3
	mov r3,rcwsiz(r1)	;set the receive window size
	inc r3
	asr r3
	mov r3,rcasiz(r1)
	movb #%corfc,pkop(r0)	;store rfc as packet opcode
	mov arg1(fp),pkdhst(r0)	;load up the destination host
	clr pkpkn(r0)		;clear the packet number field
	clr pkakn(r0)		;clear the packet acknowledgement field
	mov arg4(fp),r2		;put the pointer to contact name et al in r2
	mov #nopak,r4		;move this in case strcpy loses
	kcall strcp0		;copy it into the packet
	beq colose		;tell the poor user
	mov clock,cotimo(fp)	;get the time to give up
	add arg3(fp),cotimo(fp)	; ...
1$:	mov #icptmo,r4		;move the message for timeout
	cmp clock,cotimo(fp)	;have we tried for too long yet?
	bpl colose		;timeout on open
	kcall pktsiz		;get the size of the packet in r3
	push r5			;save our fp
	mov r0,r5		;save the good packet
	kcall alcsiz		;get another just like it (uses r3)
	if cs,<			;oh well, not enough packets
	  mov r5,r0		;resore the packet that gets returned
	  pop r5		;get back the fp
	  mov #nopak,r4		;message for out of packets
	  br colose		;give the user the lossage
	  >
	mov r5,r3		;copy packet bashes r5
	kcall coppck		;copy packet in r5 to the one in r0
	kcall trnpck		;transmit the packet
	mov r3,r0		;restore the world
	pop r5			;get back our fp
	mov clock,r3		;get the current time
	add #rfctim,r3		;add the timeout time
loop <	  cocall		;reschedule
	  cmpb #%csopn,cnstat(r1)	;did the connection open yet?
	  exitl eq		;lets tell the user the good news
	  cmpb #%csrfs,cnstat(r1)	;are we still in RFC sent state?
	  bne colos3		;we seem to have lost
	  cmp r3,clock		;compare the time to retry with the time
	  rptl pl		;not time to try RFC again yet
	  br 1$			;loop around and try the RFC again
	  >
	mov r1,out1(fp)		;return the open connection
	kcall frepck		;free the copy of the RFC packet
	return

colose:	kcall rlscon		;release the connection
colos1:	mov r4,r2		;move message string to r2
	kcall strcp0		;if this loses then give up!
	clr (r0)		;clear out the packet link field
	mov r0,out1(fp)		;return the packet with the error message
colos2:	rtnerr			;back to the shadows again

colos3: call chdati,r1,out1(fp)	;see if there is an explanation waiting
	kcall rlscon		;release the conection
	kcall frepck		;free the extra packet
	br colos2		;return to the user

;;; CHCLS: Chaos Net Close Connection.  This routine takes a connection
;;; packet and closes the connection.  It also takes a reason for the close,
;;; which can be zero, meaning use the standard message. There are no error
;;; conditions. If the connection was already closed the routine just returns.

chcls:	proc 2,0,<r0,r1,r2>
	mov arg1(fp),r1		;get the connection into the standard register
	cmpb cnstat(r1),#%cscls	;see if the connection is already closed
	beq 1$			;release the connection
	movb #%cscls,cnstat(r1)	;close the connection
	kcall alc16		;get a packet for the close
	bcs 1$			;well, we will close without telling the
				;foreign host
	movb #%cocls,pkop(r0)	;make it a close packet.
	mov trpkn(r1),pkpkn(r0)	;set the packet number
	clr pklen(r0)
	mov arg2(fp),r2		;get pointer to string for close message
	if ne,<
	  kcall strcp0
	  >
	kcall trnpck		;send the close and ignore any errors
				;the bowels of the NCP will finish off the
				;connection for us when the packet is sent.
1$:	kcall rlscon
	return

;;; CHLSN: Chaos Net Request to Listen for a Contact Name.  It takes an
;;; asciz string which is the contact name as the first argument.  The
;;; second argument is the type of listen: a zero means return the RFC
;;; when the RFC arrives, anything else is interpreted as a ptr
;;; to a routine to be run in a newly created task when the RFC is received.
;;; The new task will find the RFC packet in r0.  The return value is the
;;; RFC packet in the first case and zero in the latter.

chlsn:	proc 2,2,<r0,r2>

	clr out1(fp)		;initialize things
	kcall alc16		;make a listen packet
	bcs 4$			;no free packets so barf
	mov arg1(fp),r2		;get the string
	kcall strcp0		;copy in the contact name
	beq 3$			;string too long! but free the packet
	mov arg2(fp),lsnadr(r0)	;fill in the task start addr 
	beq 1$			;unless we are supposed to wait here
	 movb #%ptsrv,pktyp(r0)	;make it a server packet type
	 br 2$
1$:	mov fp,r2		;make ptr to place to put RFC (zeroed above)
	add #out1,r2
	mov r2,lsnrfc(r0)	;so the receiver of the RFC knows where to
				;put the packet
	mov fp,r2
	add #out2,r2
	mov r2,lsncon(r0)	;where to put the connection
	movb #%ptlsn,pktyp(r0)	;make it the right kind of packet
2$:	mov chlsnl,(r0)		;thread packet on the listen list
	mov r0,chlsnl
	cmpb #%ptsrv,pktyp(r0)	;if it's the create-a-task type then return
	beq 5$			;we are done
6$:	cocall			;wait for something to happen
	tst out1(fp)		;any mail arrive yet
	beq 6$			;not yet
5$:	return			;that's all folks

3$:	kcall frepck		;free up the allocated packet
4$:	rtnerr


;;; CHRPLY: Reply to an RFC with an OPEN.  This routine takes an
;;; RFC packet, a connection, and the window size, and
;;; sends an open to the foreign host.

chrply:	proc 3,0,<r0,r1>
	mov arg1(fp),r0		;get the RFC packet in R0.
	mov arg2(fp),r1
	clr trwsiz(r1)		;clear the transmitter window size so we
				;won't send any packets till far side sends
				;their status packet.
	mov arg3(fp),r4		;receive window size
	kcall sndopn		;open the connection
	return			;back to the poor luser

;;; CHANS: Send an Answer packet to an RFC.  This takes an RFC packet so it
;;; can be reused, a connection, a ptr to the data to be put into the ANS
;;; packet and the length of the data.  The ANS packet is send and the
;;; connection is freed.

chans:	proc 4,0,<r0,r1,r2,r3>
	mov arg1(fp),r0		;R0: RFC packet
	kcall pktsiz		;R3: size of RFC
	asl r3			;convert to bytes
	sub #pkdat,r3		;get size of text section
	cmp r3,arg4(fp)		;is there enough room?
	bge 1$			;yes, so insert the answer
	 mov arg4(fp),r3	;get another packet of the right size
	 add #pkdat+1,r3	;leave room for the header (round up)
	 asr r3			;allocate takes word count
	 push pksidx(r0),pkshst(r0),pkdhst(r0)
	 kcall frepck
	 kcall alcsiz		;get a new packet
	 bcs 5$			;we lost, cry on user's shoulder
	 pop pkdhst(r0),pkshst(r0),pksidx(r0)
1$:	mov r0,r1		;R1: ptr to packet part of the data
	add #pkdat,r1		;...
	mov arg3(fp),r2		;R2: ptr to data to send
	mov arg4(fp),r3		;R3: count of bytes
	mov r3,pklen(r0)
	if ne,<
2$:	  movb (r2)+,(r1)+	;do the copy
	  sob r3,2$
	  >
	exch pkshst(r0),pkdhst(r0),r1	;send it back
	mov pksidx(r0),pkdidx(r0)
	clr pksidx(r0)
	movb #%coans,pkop(r0)
	kcall trnpc1		;send the packet (don't set fields)
	mov arg2(fp),r1		;get the connection to free
	kcall rlscon
	return
5$:	rtnerr

;;; CHEOF: Send an EOF packet on a Connection.  This takes a connection
;;; as the first argument and sends the EOF.

cheof:	push r0			; save register
loop <	  kcall alc16		; allocate a packet
	  exitl cc
	  cocall
	  rptl
	  >
	movb #%coeof,pkop(r0)
	clr pklen(r0)
	call chdow,<r0,0+6(sp)>
	;; return CHDOW's error indication (the carry bit) for our caller
	pop r0,(sp)		; restore register, remove argument
	kretrn


;;; CHSTAT: Checks to see whether or not a packet would be accepted for
;;; transmission.  This ammounts to a check to see if the transmit window is
;;; full.  The C bit is set if data can not be accepted now or if the
;;; connection is closed.

chstat:	proc 1,0,<r1,r4>
	mov arg1(fp),r1		;get the connection
	mov trackn(r1),r4	;this the level that he has acknowledged
	add trwsiz(r1),r4	;this is the window size in that direction
	cmp r4,trpkn(r1)	;is this okay for window size?
	bmi 1$			;no
	cmpb #%csopn,cnstat(r1)	;is it open?
	bne 1$			;nope
	return
1$:	rtnerr			;caller should try again later

.sbttl User Interface - Data Output And Input Routines

;;; CHDATO: Sends a Data Packet out on a Connection.  It takes a packet and a
;;; connection.  The C bit is set if data can not be accepted now or if the
;;; connection is closed.

chdato:	proc 2,0,<r0,r1,r4>
	mov arg1(fp),r0
	mov arg2(fp),r1
	mov trackn(r1),r4	;this the level that he has acknowledged
	add trwsiz(r1),r4	;this is the window size in that direction
	cmp r4,trpkn(r1)	;is this okay for window size?
	bmi 1$			; no
	cmpb #%csopn,cnstat(r1)	;is it open?
	bne 1$			;nope, go block output
	mov trpkn(r1),pkpkn(r0)	;assign this packet its number
	inc trpkn(r1)		;and get the next packet number
	cmpb #%coeof,pkop(r0)	;did the user specify %COEOF?
	if ne,<			; no
	 bisb #%codat,pkop(r0)	;set the data bit
	 >
	kcall trnpck		;transmit this packet
	return
1$:	rtnerr			;caller should try again later


;;; CHDOW(packet, connection) -- Data output with waiting.

chdow:	push r1			; save register
	mov 4(sp),r1		; R1: connection
loop <	  call chdato,<6(sp),r1>	; try to send
	  bcc 1$			; sent
	  cmpb cnstat(r1),#%csopn	; not sent, connection still open?
	  exitl ne		; no, error return
	  cocall		; wait
	  rptl			; try again
	  >
	push 6(sp)
	call frepk
	sec			; carry set to indicate connection closed
1$:	pop r1,(sp),(sp)	; restore register, remove arguments from stack
	kretrn


;;; CHFINI: Finish all outstanding transmissions.  Wait for all packets to be
;;; ack'd.

chfini:	push r1			; save register
	mov 4(sp),r1		; R1: connection
loop <	  mov trackn(r1),-(sp)	; get packet number last ack'd
	  inc (sp)		; add 1 in order to compare with
	  cmp (sp)+,trpkn(r1)	; number of next packet
	  exitl eq		; if equal, then other side has ack'd
				; everything
	  cmpb cnstat(r1),#%csopn	; connection still open?
	  exitl ne		; no
	  cocall		; pause
	  rptl			; and then try again
	  >
	pop r1,(sp)		; restore register, remove argument
	kretrn

;;; CHDATI: Read a Data Packet from the Chaos Net on a Connection.  This
;;; takes a connection and returns a packet.  If there is no input the
;;; routine returns with the C bit set.

chdati:	proc 1,1,<r0,r1,r2>

	mov arg1(fp),r1
	clr out1(fp)
	mov rcols(r1),r0	;get the packet
	beq 4$			;nothing there
	chkpak			;if debuging, check packet validity
	mov (r0),rcols(r1)	;and link it out
	mov r0,out1(fp)		;return the guy the packet
	cmp r0,rcolse(r1)	;is it the last packet?
	if eq,<			;no, just ignore
	  conptr rcols,r2	;get abs pointer to rcols
	  mov r2,rcolse(r1)	;and set it in
	  >
	clr (r0)		;clear the packet link field
	cmpb pkop(r0),#%cocls	;close packet?
	beq 4$			;yes, just send back an error
	cmp rcacks(r1),rcsack(r1)	; ack timer currently running?
	if eq,<				; no
	  mov clock,cnackt(r1)		; start the ackwait timer to send an
	  add #ackwait,cnackt(r1)	;  ack for this packet
	  >
	mov pkpkn(r0),rcsack(r1)	; we should ack this packet
	return
4$:	rtnerr


;;; CHDIW(connection): packet -- Data input with waiting.

chdiw:	push r1			; save register
	mov 4(sp),r1		; R1: connection
loop <	  call chdati,r1,4(sp)	; read packet if any
	  bcc 1$		; got one
	  cmpb cnstat(r1),#%csopn	; no, packet; is connection still open?
	  exitl ne			; no, error return
	  cocall		; wait
	  rptl			; try again
	  >
	sec			; carry set because connection closed
1$:	pop r1			; restore register
	kretrn

	.sbttl User Interface - Packet Transmit Routine

;;; Transmit packet from current host and connection in r1 to world.

trnpck:	kcall setpck		;setup packet header from connection {01/245~

;;; Enter here when packet variables were set up elsewhere.
;;; Note: uctans depends on the fact the connection is not referred to
;;; from here on (i.e. r1 is not used).

trnpc1:	jcall catran		;add to transmit list

;;; Copy packet pointed to by r5 into the packet pointed to by r0.

coppck:	push r0,r1		;save regs
	mov pklen(r5),r1	;R1: length of the packet in bytes
	bic #pkfcnt,r1		;...
	add #pkdat-<pklnk+2>+1,r1	;include length of header, round it up
	asr r1			;bytes to words
	add #pklnk+2,r0		;skip the link field
	add #pklnk+2,r5
1$:	mov (r5)+,(r0)+		;copy packet
	sob r1,1$
	pop r1,r0
	kretrn

;;; Copy an asciz string pointed to by r2 to a packet in r0.
;;; Gets a bigger packet, if needed.  Fails if can't get a packet big enough
;;; to hold the string.  The caller must decide what to do with the packet in
;;; r0 in such cases.  The string is added after any data already in the
;;; packet, as indicated by its PKLEN.

strcp0:	clr pklen(r0)		;start out with no data
strcpy:	push r3,r5		;save registers
	bic #pkfcnt,pklen(r0)	;clear out the forwarding count, if any
10$:	mov r0,r5		;R5: pointer to data area
	add #pkdat,r5		;...
	add pklen(r0),r5	;skip over data already there
	kcall pktsiz		;get packet size in words
	asl r3			;convert to bytes
	sub #pkdat,r3		;account for the header, etc.
	sub pklen(r0),r3	;reduce the count by amount already filled
	if mi,<
	  bpt
	  >
	beq 3$
1$:	movb (r2)+,(r5)+	;copy the string into the packet
	beq 2$			;loop until a null byte is reached
	inc pklen(r0)
	sob r3,1$		;is there still room in the packet?
3$:	;; current packet is not big enough
	mov r0,r5		;save the current packet in r5
	mov pklen(r0),r3
	add #pkdat+20.,r3	;try 20 extra bytes
	asr r3			;convert to words
	kcall alcsiz		;try to get it (puts a new pkt ptr into r0)
	bcs 90$			;failed, so punt, returning the existing r0
	push r0			;save new packet pointer
	push r5			;save old packet pointer
	kcall coppck		;copy old into new
	pop r0			;restore old packet pointer
	kcall frepck		;free the old packet (don't care about error?)
	pop r0			;restore new packet pointer
	br 10$			;and continue
2$:	pop r5,r3		;restore registers
	clz
	kretrn

90$:	mov r5,r0		;get back the full packet
	pop r5,r3		;restore registers
	sez			;error return
	kretrn
	.sbttl Connection Allocation

;;; Search for a free slot in the connection table and if one is found
;;; allocate a connection packet for the per connection data

allcon:	push r0,r2,r3
	mov #cn.ln/2,r3
	kcall alcsiz
	bcs allfai		;sorry, space available for the connection
	clr r1
	mov #ncons,r2		;put number of connections in r2
2$:	tst contbl(r1)		;is this a free connection slot?
	beq 3$			;found a free connection, grab it
	add #2,r1
	sob r2,2$		;keep going
	 kcall frepck		;free the packet
	 br allfai
3$:	mov r1,r2
	asr r2
	movb r2,cnlidx(r0)	;store the connection index in the packet
	mov r0,contbl(r1)	;store the packet in the table
	mov r0,r1		;R1 normally contains a conn. packet pointer
	pop r3,r2,r0

;;; Entry point to initialize or reset a pre-allocated connection.

rstcon:	push r0,cnlidx(r1)	;save the index for later
	mov #cn.ln/2,r0		;size of packet in words
1$:	clr (r1)+		;clear a word
	sob r0,1$		;loop around
	sub #cn.ln,r1		;restore r1 by subtracting the size in bytes
	pop cnlidx(r1),r0
	mov #1,cnrcnt(r1)
	incb unikey		;step the unique-id key and make sure it's never
	if eq,<inc unikey>	;zero since a connection index of zero is illegal
	movb unikey,cnlunq(r1)	;set it for this connection
	mov #1,trpkn(r1)	;the next packet number is 1
	mov r1,rcolse(r1)
	add #rcols,rcolse(r1)
	mov #6*8,cnrtim(r1)	;init round trip time to .1sec
;	clz
	kretrn

;;; Connection allocation failed for various reasons

allfai:	inc allfct		;update the count of failures
	pop r3,r2,r0
	sez
	kretrn

;;; Release a connection.  R1/ connection.

rlscon:	push r0,r2		;save registers
	movb cnlidx(r1),r0
	asl r0
	cmp contbl(r0),r1	;were we really given a connection?
	if ne,<			; no!
	  bpt
	  >
	dec cnrcnt(r1)		;decrement reference count
	if le,<			;if went to 0
	  mov rcuols(r1),r2	;free the out of order list
	  kcall frelst
	  clr rcuols(r1)	;make sure we don't try twice
	  mov rcols(r1),r2	;free the buffered packets
	  kcall frelst
	  clr rcols(r1)		;make sure we don't try twice
	  mov trrcvl(r1),r2	;free the receipt list
	  kcall frelst
	  clr trrcvl(r1)	;make sure we don't try twice
	  clr contbl(r0)	;clear the table entry
	  mov r1,r0		;and free the packet
	  kcall frepck
	  >
	clr r1			;connection = 0 is free
	pop r2,r0		;restore registers
	kretrn

;;; Frees a whole list of packets pointed to by r2.

frelst:	push r0
1$:	mov r2,r0		;get the first packet
	beq 2$			;if zero then nothing to free
	mov (r0),r2		;get next packet on the list
	kcall frepck
	br 1$
2$:	pop r0
	kretrn

;;; CHCONN(fhost, fidx): connection.
;;; Create a choasnet connection without opening.  For random hacks.

chconn:	proc 2,1,<r1>
	kcall allcon    	; allocate a connection
	beq 1$			; no connections?
	mov arg1(fp),cnfhst(r1)	; set foreign host name
	mov arg2(fp),cnfidx(r1)	; set foreign index
	movb #%csfrn,cnstat(r1)	; connection state is foreign protocol
	mov r1,out1(fp)
	return
1$:	rtnerr


;;; CHPKTO(packet, connection).  Output random packet.

chpkto:	push r0,r1		; save registers
	mov 10(sp),r0		; R0: packet
	mov 6(sp),r1		; R1: connection
	kcall trnpck    	; put on transmit list
	pop r1,r0,(sp),(sp)	; restore registers, remove arguments
	kretrn

;;; CHPKTI(connection): packet.  Get random packet.  Return zero if none.

chpkti:	push r1			; save register
	mov 4(sp),r1    	; R1: connection
	mov rcols(r1),4(sp)	; return packet if any
	if ne,<			; there is one
	  mov @4(sp),rcols(r1)	; remove it from list
	  if eq,<		; it is last packet on list
	    mov r1,rcolse(r1)		; so set end of list pointer
	    add #rcols,rcolse(r1)	; to list header
	    >
	  >
	pop r1			; restore register
	kretrn

	.sbttl Initialization Routines

;;; CHINIT: Chaos Net Initialization Routine
;;; This routine should be called to initialize the CHAOS NCP.  It can be
;;; called more than once, however, each time will completely re-start
;;; the network destroying all outstanding connections.

chinit:	proc 0,0,<>

	mov #chtvst,r0		;get pointer to variables to clear
	mov #chtvln,r1		;and length
1$:	clr (r0)+		;clear out ncp variables
	sob r1,1$
	mov #rcvpkl,rcvpke	;initialize the receive packet list
	mov #chtpak,chtpke	;initialize the transmit packet list

	mov #innet_8+inhst,myhost	;set up my host number

	call crtask,<#0,#0,#0,#0,#0,#0,#chsrcv>,tcbrcv
				;create task and save the tcb pointer
	bcc 2$			;ok, create the transmitter
	bpt
2$:	call crtask,<#0,#0,#0,#0,#0,#0,#chsxmt>,tcbxmt
				;create task and save the tcb pointer
	bcc 3$			;ok, one more to go
	bpt
3$:	call crtask,<#0,#0,#0,#0,#0,#0,#chsclk>,tcbclk
				;we are down with the tasks now
	bcc 4$			;finish un initialization
	bpt
4$:	oncini			;do the once only initialization for each
				;kind of transceiver
	mov #ciftbl,r1		;get the pointer to the cif table
5$:	clrb ci.sts(r1)		;clear out the status bits
	clr ci.pkt(r1)		;clear out the last packet sent
	clr ci.rcn+0(r1)	;clear statistics
	clr ci.rcn+2(r1)
	clr ci.tcn+0(r1)
	clr ci.tcn+2(r1)
	mov clock,ci.rut(r1)
	mov ci.ini(r1),r2	;get pointer to initialize routine
	beq 6$			;if zero, then no program
	kcall (r2)		;call the routine, r1 is its table entry
6$:	add #cif.ln,r1		;point to next entry in table
	cmp r1,#cifend		;at the end of the table
	blo 5$

	call chlsn,<#stsnam,#stsser>,<r0,r0>	; create STATUS server
	call chlsn,<#drtnam,#drtser>,<r0,r0>	; create routing server

	return

.sbttl	STATUS server

;;; Task created and started here with R0/ RFC, R1/ connection.
stsser:	mov r0,r5		; R5: RFC
	mov #<32.+<cifcnt*<lsdata+4>>>/2,r3	; ALCSIZ arg: size in words
	call alcsiz		; allocate status packet data area
	bcs seralf		; failed
	mov #ciftbl+ci.sda,r2	; R2: interface table entry
	add #32.,r0		; skip name field
loop <	  movb ci.net-ci.sda(r2),(r0)+
	  movb #1,(r0)+
	  mov #lsdata/2,r4
	  mov r4,(r0)+
  loop <    mov (r2)+,(r0)+
	    sorl r4
	    >
	  add #cif.ln-lsdata,r2
	  cmp r2,#cifend
	  rptl lo
	  >
serans:	asl r3			; convert to bytes
	sub r3,r0
	call chans,<r5,r1,r0,r3>	; send ANS
	call frepck		; free STATUS data
	jcall logout


drtser:	mov r0,r5		; R5: RFC
	mov #mxsbnt*4/2,r3	; ALCSIZ arg: size in words
	call alcsiz		; allocate place for ANS data
	bcs seralf
	mov #mxsbnt,r4
	mov #chrcst,r2
loop <    mov chradr-chrcst(r2),(r0)+
	  mov (r2)+,(r0)+
	  sorl r4
	  >
	br serans


seralf:	mov r5,r0
	call frepck		; free RFC
	call chcls,<r1,#0>	; refuse
	jcall logout

	.sbttl Chaos Net Statistics printer

;;; This routine has been extracted from the NSWIT machine.  Since NSWIT
;;; calls it some of its conventions must be observed.  The most important
;;; of these is that the current task's context pointer is always kept in
;;; R0 and output to the terminal can not work if R0 is set to anything
;;; besides what this routine was called with.  All the output done by
;;; this routine is done using IOA.  This routine must inserts IOA's
;;; macros since macros cannot be forward referenced.  R0 and R5 preserved,
;;; others bashed.

ioamacros==1			; just define the macros.
	.insrt ioa
ioamacros==0

chprst:	push r5			; Chaos NCP Print Status
	mov #contbl,r5
	mov #ncons,r4
	mov #-1,r3
loop <	  mov (r5)+,r1
	  if ne,<
	    inc r3
	    if eq,<
	      ioa ^"
S F-host F-idx  L-idx  T/Rwin Tpacket  Rpacket retrs retrt dupkt T-STS RTim Idl^/"
	      >
	    kcall chprcn	; print out the connection in R1
	    >
	  sorl r4		;out of range
	  >
	ioa ^"Servers:"
	mov chlsnl,r1
	if ne,<
loop <	  mov r1,r2
	  add #pkdat,r2
	  ioa ^" ^a",<r2>
	  mov (r1),r1
	  rptl ne
	  >
	>
	ioa ^"^/"		; terpri
	pop r5
	kretrn

;;; This is the inner loop, it just prints out the data for one connection
;;; It bashes r2.

chprcn:	push r3
	movb cnstat(r1),r3	; get the status of the connection
	movb cnslet(r3),r2
	ioa ^"^c ",<r2>
	mov #fhaddr,r3
	clr r2
loop <	  cmp (r3),cnfhst(r1)
	  exitl eq
	  tst (r3)+
	  tst (r3)		; end of list?
	  rptl ne
	  >
	mov fhname-fhaddr(r3),r2	; get the name of that host
	if eq,<
	  ioa ^"^o ",<cnfhst(r1)>
	  >
	else <
	  ioa ^"^a ",<r2>
	  >

	ioa ^"^o ^o ^2d/^2d ^5d",<cnfidx(r1),cnlidx(r1),trwsiz(r1),rcwsiz(r1),trackn(r1)>
	mov trrcvn(r1),r2
	mov trpkn(r1),r3
	sub trackn(r1),r2
	sub trackn(r1),r3
	dec r3			; trpkn is always one ahead, so normalize to 0
	ioa ^"+^1d+^1d ",<r2,r3>

	mov rcsack(r1),r2
	sub rcacks(r1),r2
	ioa ^"^5d+^1d ",<rcacks(r1),r2>
	ioa ^"^5d ^5d ^5d ^5d",<cnrtsc(r1),cnrttc(r1),cndupk(r1),cntsts(r1)>

	mov cnrtim(r1),r2	; get response time * 8
	mov r2,r3
	asl r2			; 60 * 16 = 960
	ash #-4,r3		; + .5 
	add r3,r2		; 60 * 16.5 = 990
	asr r3			; + .125
	asr r3			; ...
	add r3,r2		; 60 * 16.625 = 997.5
	ioa ^" ^4d ",<r2>	; response time in milliseconds
	mov clock,r3
	sub cnact(r1),r3
	sxt r2
	div #60.,r2
	if mi,<
	  ioa ^"-"
	  neg r2
	  >
	ioa ^"^3d^/",<r2>
	pop r3
	kretrn

fhaddr:	.word s1vax,arpa,aswit,bswit,cswit,dswit,lswit,oswit,rswit,0
fhname:	.word 1$,2$,3$,4$,5$,6$,7$,8$,9$,0
1$:	.asciz "VAX   "
2$:	.asciz "ARPA  "
3$:	.asciz "ASWIT "
4$:	.asciz "BSWIT "
5$:	.asciz "CSWIT "
6$:	.asciz "DSWIT "
7$:	.asciz "LSWIT "
8$:	.asciz "OSWIT "
9$:	.asciz "RT-11 "

cnslet: .ascii "CLRSFOBI"
	.even

	.sbttl NCP Variable Definitions

;;; Random constants for use by the NCP

defvar <
chtvst===.			;start of variables to be cleared on init

;;;variables for statistics gathering

caovfw:	0			;count of overforwarded packets
calost:	0			;total number of packets lost
caabtc:	0			;total abort count
cartab:	0			;# of aborts of packets being retransmitted
cacrc:	0			;total number of crc errors
caperr:	0			;total number of packet format errors
cameml:	0			;number of times that the hw memory lost
canpkb:	0			;number of times when no packet buffers 
				;on input interrupt level
cauorp:	0			;number of out of order acknowledgments
carwov:	0			;receive window overflow count
casns:	0			;number of sense packets sent
casts:	0			;number of status packets sent back
casnst:	0			;number of statuses sent due to snses
cawsts:	0			;number of statuses due to window full
; cadupk:	0		;number of duplicate packets received,
				; kept per connection, see "cndupk"
caopns:	0			;number of connections opened
catlst:	0			;number of packets lost due to our slowness
canrpk:	0			;number of packets received
cantpk:	0			;number of packets transmitted
canord:	0			;number of times packet are received
				;out of order
allfct:	0			;count of failed connection allocations
tcbrcv:	0			;tcb ptr to the receiver task
tcbxmt:	0			;ptr to the tcb of the transmitter task
tcbclk:	0			;tcb of the task that does probing etc.

;;; variables that are not per connection

chtpak:	0			;transmitter interrupt packet list
chtpke:	chtpak			;last packet on CHTPAK
chtlas:	0			;pointer to the last packet transmitted
rcvpkl:	0			;received packet list
rcvpke:	0			;end of the above list
chtsav:	0			;save last packet xmitted (for debugging)
chlsnl:	0			;list of LSN packets
contbl:	.blkw ncons		;table of connection packet pointers

nxtage:	.word 0			;time to next age the routing table

chtvln===<.-chtvst>/2		;end of variables to be cleared

myhost:	0			;our network address (including subnet)
mynet==myhost+1			;our subnet number

unikey:	.			;connection index uniquizer key
>				; end defvar

;;; CHAOS Net Interface Table
;;; This table defines the available interfaces to the various subnets
;;; that this host resides on.  It contains the interface status word
;;; used to communicate between the device driver and the NCP as well as
;;; the address of the transmitter and receiver programs that deal
;;; with hardware interfaces.

dsect <
ci.sts:: .blkb 1		;status of interface (xmt and rcv)
ci.pad:: .blkb 1		;padding byte
ci.hst:: .blkb 1		;host of this machine on the this net
ci.net:: .blkb 1		;network on which this interface resides
ci.xmt:: .blkw 1		;address of the transmitter routine
				;takes the packet to send in r0 and
				;the host in r4
ci.pkt:: .blkw 1		;pointer to the packet last sent
ci.mab:: .blkw 1		;maximum number of times a packet can be
				;aborted before it is thrown away by the xmtr
ci.abc:: .blkw 1		;abort count
ci.rab:: .blkw 1		;count of multiple aborts on the same packet
ci.rcv:: .blkw 1		;pointer to the receiver routine.  The
				;procedure allocates a packet and threads it
				;onto the receive list.  If this pointer is
				;zero then the packet is threaded on at
				;interrupt level
ci.ini:: .blkw 1		;the initialization routine for the xcvr
ci.dat:: .blkw 1		;the data area for the xcvr, the format
				;is defined by the type of transmitter
ci.cst:: .blkw 1		;cost of routing over this subnet
ci.rut:: .blkw 1		;time to send next RUT

;;; STATUS packet data
ci.sda::
ci.rcn:: .blkw 2		; receive count
ci.tcn:: .blkw 2		; transmit count
lsdata==.-ci.sda
	>,cif.ln

%rcvrd===1			;receiver ready bit
%xmtrd===2			;transmitter ready bit
%xmtab===4			;transmitter aborted last transmission

insrtr				;insert the tranceivers here

defvar <

chrcst:
.rept mxsbnt
	.word maxage
.endr
chradr:
.rept mxsbnt
	.word 0
.endr
chrtyp:
.rept mxsbnt
	.byte %rtbrg
.endr
.even

mkcftb				;set down the cif table
>

;;; These are the string for the various messages that are placed in packets.
;;; Some of these are messages to the local user, other ones are sent to
;;; the foreign host.  All the messages are asciz strings.

;;; Connection Timeout message

tmomsg:	.asciz /Connection broken.  Foreign host not responding. [CHAOS]/

;;; LOSE messages

bimsg:	.asciz /Non-existent index!! Connection was broken. [CHAOS]/
cclmsg:	.asciz /Connection was closed!! [CHAOS]/
bopmsg:	.asciz /Bad opcode in packet!! [CHAOS]/
bstmsg:	.asciz /Connection in the wrong state!! [CHAOS]/
ciimsg:	.asciz /Connection index inconsistent [CHAOS]/

;;; RFC and LSN failure messages

sflmsg:	.asciz /Unable to create server task [CHAOS]/
icptmo:	.asciz /Attempt to connect to foreign host has timed-out.  [CHAOS]/
unkctn:	.asciz / - Unknown Contact Name [CHAOS]/
noconn:	.asciz /Unable to allocate a connection [CHAOS]/
nopak:	.asciz /Unable to allocate a packet [CHAOS]/

;;; Contact names
stsnam:	.asciz "STATUS"
drtnam:	.asciz "DUMP-ROUTING-TABLE"

	.even
